"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils/utils");
/**
 * @param bin the raw transaction from which to read the input
 * @param offset the offset at which the input begins
 */
exports.readTransactionInput = (bin, offset) => {
    const offsetAfterTxHash = offset + 32 /* sha256Hash */;
    const outpointTransactionHash = bin
        .slice(offset, offsetAfterTxHash)
        .reverse();
    const offsetAfterOutpointIndex = offsetAfterTxHash + 4 /* uint32 */;
    const outpointIndex = utils_1.binToNumberUint32LE(bin.subarray(offsetAfterTxHash, offsetAfterOutpointIndex));
    const { nextOffset: offsetAfterScriptLength, value: scriptLength } = utils_1.readBitcoinVarInt(bin, offsetAfterOutpointIndex);
    const offsetAfterScript = offsetAfterScriptLength + Number(scriptLength);
    const unlockingBytecode = bin.slice(offsetAfterScriptLength, offsetAfterScript);
    const nextOffset = offsetAfterScript + 4 /* uint32 */;
    const sequenceNumber = utils_1.binToNumberUint32LE(bin.subarray(offsetAfterScript, nextOffset));
    return {
        input: {
            outpointIndex,
            outpointTransactionHash,
            sequenceNumber,
            unlockingBytecode
        },
        nextOffset
    };
};
/**
 * Serialize a single input.
 * @param output the input to serialize
 */
exports.serializeInput = (input) => utils_1.flattenBinArray([
    input.outpointTransactionHash.slice().reverse(),
    utils_1.numberToBinUint32LE(input.outpointIndex),
    utils_1.bigIntToBitcoinVarInt(BigInt(input.unlockingBytecode.length)),
    input.unlockingBytecode,
    utils_1.numberToBinUint32LE(input.sequenceNumber)
]);
/**
 * Serialize a set of inputs for inclusion in a serialized transaction.
 *
 * Format: <BitcoinVarInt: input count> <serialized inputs>
 *
 * @param inputs the set of inputs to serialize
 */
exports.serializeInputs = (inputs) => utils_1.flattenBinArray([
    utils_1.bigIntToBitcoinVarInt(BigInt(inputs.length)),
    ...inputs.map(exports.serializeInput)
]);
/**
 * @param bin the raw transaction from which to read the output
 * @param offset the offset at which the output begins
 */
exports.readTransactionOutput = (bin, offset) => {
    const offsetAfterSatoshis = offset + 8 /* uint64 */;
    const satoshis = utils_1.binToBigIntUint64LE(bin.subarray(offset, offsetAfterSatoshis));
    const { nextOffset: offsetAfterScriptLength, value } = utils_1.readBitcoinVarInt(bin, offsetAfterSatoshis);
    const scriptLength = Number(value);
    const nextOffset = offsetAfterScriptLength + scriptLength;
    const lockingBytecode = scriptLength === 0
        ? new Uint8Array()
        : bin.slice(offsetAfterScriptLength, nextOffset);
    return {
        nextOffset,
        output: {
            lockingBytecode,
            satoshis
        }
    };
};
/**
 * Serialize a single output.
 * @param output the output to serialize
 */
exports.serializeOutput = (output) => utils_1.flattenBinArray([
    utils_1.bigIntToBinUint64LE(BigInt(output.satoshis)),
    utils_1.bigIntToBitcoinVarInt(BigInt(output.lockingBytecode.length)),
    output.lockingBytecode
]);
/**
 * Serialize a set of outputs for inclusion in a serialized transaction.
 *
 * Format: <BitcoinVarInt: output count> <serialized outputs>
 *
 * @param outputs the set of outputs to serialize
 */
exports.serializeOutputsForTransaction = (outputs) => utils_1.flattenBinArray([
    utils_1.bigIntToBitcoinVarInt(BigInt(outputs.length)),
    ...outputs.map(exports.serializeOutput)
]);
/**
 * TODO: document return type (note outpointTransactionHash is little-endian â€“ most UIs display big-endian transaction hashes)
 *
 * Note: this method throws runtime errors when attempting to decode improperly
 * encoded transactions.
 *
 * @param bin the raw transaction to decode
 */
exports.deserializeTransaction = (bin) => {
    const version = utils_1.binToNumberUint32LE(bin.subarray(0, 4 /* uint32 */));
    const offsetAfterVersion = 4 /* uint32 */;
    const { nextOffset: offsetAfterInputCount, value: inputCount } = utils_1.readBitcoinVarInt(bin, offsetAfterVersion);
    // eslint-disable-next-line functional/no-let
    let cursor = offsetAfterInputCount;
    const inputs = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < Number(inputCount); i++) {
        const { input, nextOffset } = exports.readTransactionInput(bin, cursor);
        // eslint-disable-next-line functional/no-expression-statement
        cursor = nextOffset;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        inputs.push(input);
    }
    const { nextOffset: offsetAfterOutputCount, value: outputCount } = utils_1.readBitcoinVarInt(bin, cursor);
    // eslint-disable-next-line functional/no-expression-statement
    cursor = offsetAfterOutputCount;
    const outputs = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < Number(outputCount); i++) {
        const { output, nextOffset } = exports.readTransactionOutput(bin, cursor);
        // eslint-disable-next-line functional/no-expression-statement
        cursor = nextOffset;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        outputs.push(output);
    }
    const locktime = utils_1.binToNumberUint32LE(bin.subarray(cursor, cursor + 4 /* uint32 */));
    return {
        inputs,
        locktime,
        outputs,
        version
    };
};
/**
 * TODO: doc
 */
exports.serializeTransaction = (tx) => utils_1.flattenBinArray([
    utils_1.numberToBinUint32LE(tx.version),
    exports.serializeInputs(tx.inputs),
    exports.serializeOutputsForTransaction(tx.outputs),
    utils_1.numberToBinUint32LE(tx.locktime)
]);
/**
 * Derive a standard identifier from a serialized data structure.
 *
 * @remarks
 * By convention, Bitcoin transaction and block identifiers are derived by
 * double-sha256 hashing their serialized form, and reversing the byte order.
 * (The result of sha256 is defined by its specification as big-endian, and
 * bitcoin displays hashes in little-endian format.)
 *
 * @returns an identifier in little-endian byte order
 *
 * @param data the serialized raw data being identified
 * @param sha256 an implementation of sha256
 */
exports.getBitcoinIdentifier = (data, sha256) => sha256.hash(sha256.hash(data)).reverse();
/**
 * Derive a standard transaction identifier from a serialized transaction.
 *
 * @returns a Transaction ID in little-endian byte order
 *
 * @param transaction the serialized transaction
 * @param sha256 an implementation of sha256
 */
exports.getBitcoinTransactionId = (transaction, sha256) => utils_1.binToHex(exports.getBitcoinIdentifier(transaction, sha256));
/**
 * Get the hash of all outpoints in a series of inputs. (For use in
 * `hashTransactionOutpoints`.)
 *
 * @param inputs the series of inputs from which to extract the outpoints
 * @param sha256 an implementation of sha256
 */
exports.serializeOutpoints = (inputs) => utils_1.flattenBinArray(inputs.map(i => utils_1.flattenBinArray([
    i.outpointTransactionHash.slice().reverse(),
    utils_1.numberToBinUint32LE(i.outpointIndex)
])));
/**
 * Get the signing serialization for a series of outputs.
 * @param outputs the series of outputs to serialize
 */
exports.serializeOutputsForSigning = (outputs) => utils_1.flattenBinArray(outputs.map(exports.serializeOutput));
/**
 * Serialize a series of input sequence numbers.
 *
 * @param inputs the series of inputs from which to extract the sequence numbers
 */
exports.serializeSequenceNumbers = (inputs) => utils_1.flattenBinArray(inputs.map(i => utils_1.numberToBinUint32LE(i.sequenceNumber)));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EseUNBU3VCO0FBa0h2Qjs7O0dBR0c7QUFDVSxRQUFBLG9CQUFvQixHQUFHLENBQUMsR0FBZSxFQUFFLE1BQWMsRUFBRSxFQUFFO0lBQ3RFLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxzQkFBd0IsQ0FBQztJQUN6RCxNQUFNLHVCQUF1QixHQUFHLEdBQUc7U0FDaEMsS0FBSyxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQztTQUNoQyxPQUFPLEVBQUUsQ0FBQztJQUNiLE1BQU0sd0JBQXdCLEdBQUcsaUJBQWlCLGlCQUFvQixDQUFDO0lBQ3ZFLE1BQU0sYUFBYSxHQUFHLDJCQUFtQixDQUN2QyxHQUFHLENBQUMsUUFBUSxDQUFDLGlCQUFpQixFQUFFLHdCQUF3QixDQUFDLENBQzFELENBQUM7SUFDRixNQUFNLEVBQ0osVUFBVSxFQUFFLHVCQUF1QixFQUNuQyxLQUFLLEVBQUUsWUFBWSxFQUNwQixHQUFHLHlCQUFpQixDQUFDLEdBQUcsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO0lBQ3JELE1BQU0saUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3pFLE1BQU0saUJBQWlCLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FDakMsdUJBQXVCLEVBQ3ZCLGlCQUFpQixDQUNsQixDQUFDO0lBQ0YsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLGlCQUFvQixDQUFDO0lBQ3pELE1BQU0sY0FBYyxHQUFHLDJCQUFtQixDQUN4QyxHQUFHLENBQUMsUUFBUSxDQUFDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxDQUM1QyxDQUFDO0lBQ0YsT0FBTztRQUNMLEtBQUssRUFBRTtZQUNMLGFBQWE7WUFDYix1QkFBdUI7WUFDdkIsY0FBYztZQUNkLGlCQUFpQjtTQUNsQjtR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