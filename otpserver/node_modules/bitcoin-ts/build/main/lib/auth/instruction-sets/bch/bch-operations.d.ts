import { Secp256k1, Sha256 } from '../../../crypto/crypto';
import { AuthenticationProgramStateCommon, ErrorState, StackState } from '../../state';
import { AuthenticationErrorCommon } from '../common/errors';
import { AuthenticationErrorBCH } from './bch-errors';
import { OpcodesBCH } from './bch-opcodes';
export declare const opCat: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>() => (state: State) => State;
export declare const opSplit: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>(flags: {
    requireMinimalEncoding: boolean;
}) => (state: State) => State;
export declare const padMinimallyEncodedScriptNumber: (scriptNumber: Uint8Array, length: number) => Uint8Array;
export declare const opNum2Bin: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>() => (state: State) => State;
export declare const opBin2Num: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>() => (state: State) => State;
export declare const bitwiseOperation: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>(combine: (a: Uint8Array, b: Uint8Array) => Uint8Array) => (state: State) => State;
export declare const opAnd: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>() => (state: State) => State;
export declare const opOr: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>() => (state: State) => State;
export declare const opXor: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>() => (state: State) => State;
export declare const opDiv: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>(flags: {
    requireMinimalEncoding: boolean;
}) => (state: State) => State;
export declare const opMod: <State extends StackState<Uint8Array> & ErrorState<AuthenticationErrorBCH, AuthenticationErrorCommon>>(flags: {
    requireMinimalEncoding: boolean;
}) => (state: State) => State;
/**
 * Validate the encoding of a raw signature â€“ a signature without a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param signature the raw signature
 */
export declare const isValidSignatureEncodingBCHRaw: (signature: Uint8Array) => boolean;
export declare const opCheckDataSig: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(sha256: Sha256, secp256k1: Secp256k1) => (state: State) => State;
export declare const opCheckDataSigVerify: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(sha256: Sha256, secp256k1: Secp256k1) => (state: State) => State;
export declare const bitcoinCashOperations: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, AuthenticationErrorBCH>>(sha256: Sha256, secp256k1: Secp256k1, flags: {
    requireBugValueZero: boolean;
    requireMinimalEncoding: boolean;
    requireNullSignatureFailures: boolean;
}) => {
    [OpcodesBCH.OP_CAT]: (state: State) => State;
    [OpcodesBCH.OP_SPLIT]: (state: State) => State;
    [OpcodesBCH.OP_NUM2BIN]: (state: State) => State;
    [OpcodesBCH.OP_BIN2NUM]: (state: State) => State;
    [OpcodesBCH.OP_AND]: (state: State) => State;
    [OpcodesBCH.OP_OR]: (state: State) => State;
    [OpcodesBCH.OP_XOR]: (state: State) => State;
    [OpcodesBCH.OP_DIV]: (state: State) => State;
    [OpcodesBCH.OP_MOD]: (state: State) => State;
    [OpcodesBCH.OP_CHECKDATASIG]: (state: State) => State;
    [OpcodesBCH.OP_CHECKDATASIGVERIFY]: (state: State) => State;
};
//# sourceMappingURL=bch-operations.d.ts.map