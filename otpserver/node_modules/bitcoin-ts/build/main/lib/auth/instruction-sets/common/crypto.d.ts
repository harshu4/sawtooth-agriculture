import { Ripemd160, Secp256k1, Sha1, Sha256 } from '../../../crypto/crypto';
import { AuthenticationProgramStateCommon, ErrorState, MinimumProgramState, StackState } from '../../state';
import { Operation } from '../../virtual-machine';
import { AuthenticationErrorCommon } from './errors';
import { OpcodesCommon } from './opcodes';
export { Ripemd160, Sha1, Sha256, Secp256k1 };
export declare const opRipemd160: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(ripemd160: Ripemd160) => Operation<State>;
export declare const opSha1: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(sha1: Sha1) => Operation<State>;
export declare const opSha256: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(sha256: Sha256) => Operation<State>;
export declare const opHash160: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(sha256: Sha256, ripemd160: Ripemd160) => Operation<State>;
export declare const opHash256: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(sha256: Sha256) => Operation<State>;
export declare const opCodeSeparator: <Opcodes, State extends MinimumProgramState<Opcodes> & {
    lastCodeSeparator: number;
}>() => Operation<State>;
export declare const opCheckSig: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>(sha256: Sha256, secp256k1: Secp256k1, flags: {
    requireNullSignatureFailures: boolean;
}) => Operation<State>;
export declare const opCheckMultiSig: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>(sha256: Sha256, secp256k1: Secp256k1, flags: {
    requireBugValueZero: boolean;
    requireMinimalEncoding: boolean;
    requireNullSignatureFailures: boolean;
}) => (s: State) => State;
export declare const opCheckSigVerify: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>(sha256: Sha256, secp256k1: Secp256k1, flags: {
    requireNullSignatureFailures: boolean;
}) => Operation<State>;
export declare const opCheckMultiSigVerify: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>(sha256: Sha256, secp256k1: Secp256k1, flags: {
    requireBugValueZero: boolean;
    requireMinimalEncoding: boolean;
    requireNullSignatureFailures: boolean;
}) => Operation<State>;
export declare const cryptoOperations: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>(sha1: Sha1, sha256: Sha256, ripemd160: Ripemd160, secp256k1: Secp256k1, flags: {
    requireBugValueZero: boolean;
    requireMinimalEncoding: boolean;
    requireNullSignatureFailures: boolean;
}) => {
    [OpcodesCommon.OP_RIPEMD160]: Operation<State>;
    [OpcodesCommon.OP_SHA1]: Operation<State>;
    [OpcodesCommon.OP_SHA256]: Operation<State>;
    [OpcodesCommon.OP_HASH160]: Operation<State>;
    [OpcodesCommon.OP_HASH256]: Operation<State>;
    [OpcodesCommon.OP_CODESEPARATOR]: Operation<State>;
    [OpcodesCommon.OP_CHECKSIG]: Operation<State>;
    [OpcodesCommon.OP_CHECKSIGVERIFY]: Operation<State>;
    [OpcodesCommon.OP_CHECKMULTISIG]: (s: State) => State;
    [OpcodesCommon.OP_CHECKMULTISIGVERIFY]: Operation<State>;
};
//# sourceMappingURL=crypto.d.ts.map