"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../../utils/utils");
/* eslint-disable camelcase */
/**
 * A.K.A. `sighash` flags
 */
var SigningSerializationFlag;
(function (SigningSerializationFlag) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationFlag[SigningSerializationFlag["all_outputs"] = 1] = "all_outputs";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationFlag[SigningSerializationFlag["no_outputs"] = 2] = "no_outputs";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationFlag[SigningSerializationFlag["corresponding_output"] = 3] = "corresponding_output";
    SigningSerializationFlag[SigningSerializationFlag["fork_id"] = 64] = "fork_id";
    /**
     * A.K.A `ANYONE_CAN_PAY`
     */
    SigningSerializationFlag[SigningSerializationFlag["single_input"] = 128] = "single_input";
})(SigningSerializationFlag = exports.SigningSerializationFlag || (exports.SigningSerializationFlag = {}));
exports.isDefinedSigningSerializationType = (byte) => {
    const baseType = 
    // eslint-disable-next-line no-bitwise
    byte &
        // eslint-disable-next-line no-bitwise
        ~(SigningSerializationFlag.fork_id | SigningSerializationFlag.single_input);
    return (baseType >= SigningSerializationFlag.all_outputs &&
        baseType <= SigningSerializationFlag.corresponding_output);
};
const match = (type, flag) => 
// eslint-disable-next-line no-bitwise
(type[0] & flag) !== 0;
const equals = (type, flag
// eslint-disable-next-line no-bitwise
) => (type[0] & 31 /* mask5Bits */) === flag;
const shouldSerializeSingleInput = (type) => match(type, SigningSerializationFlag.single_input);
const shouldSerializeCorrespondingOutput = (type) => equals(type, SigningSerializationFlag.corresponding_output);
const shouldSerializeNoOutputs = (type) => equals(type, SigningSerializationFlag.no_outputs);
const emptyHash = () => new Uint8Array(32 /* sha256HashByteLength */).fill(0);
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutpoints see `generateSigningSerializationBCH`
 */
exports.hashPrevouts = (sha256, signingSerializationType, transactionOutpoints) => shouldSerializeSingleInput(signingSerializationType)
    ? emptyHash()
    : sha256.hash(sha256.hash(transactionOutpoints));
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionSequenceNumbers see
 * `generateSigningSerializationBCH`
 */
exports.hashSequence = (sha256, signingSerializationType, transactionSequenceNumbers) => !shouldSerializeSingleInput(signingSerializationType) &&
    !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionSequenceNumbers))
    : emptyHash();
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutputs see `generateSigningSerializationBCH`
 * @param correspondingOutput see `generateSigningSerializationBCH`
 */
exports.hashOutputs = (sha256, signingSerializationType, transactionOutputs, correspondingOutput) => !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionOutputs))
    : shouldSerializeCorrespondingOutput(signingSerializationType)
        ? correspondingOutput === undefined
            ? emptyHash()
            : sha256.hash(sha256.hash(correspondingOutput))
        : emptyHash();
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * @param version the version number of the transaction
 * @param transactionOutpoints the serialization of all input outpoints (A.K.A.
 * `hashPrevouts`) – used if `ANYONECANPAY` is not set
 * @param transactionSequenceNumbers the serialization of all input sequence
 * numbers. (A.K.A. `hashSequence`) – used if none of `ANYONECANPAY`, `SINGLE`,
 * or `NONE` are set.
 * @param outpointTransactionHash the big-endian (standard) transaction hash of
 * the outpoint being spent.
 * @param outpointIndex the index of the outpoint being spent in
 * `outpointTransactionHash`
 * @param coveredBytecode the script currently being executed, beginning at the
 * `lastCodeSeparator`.
 * @param outputValue the value of the outpoint in satoshis
 * @param sequenceNumber the sequence number of the input (A.K.A. `nSequence`)
 * @param correspondingOutput the serialization of the output at the same index
 * as this input (A.K.A. `hashOutputs` with `SIGHASH_SINGLE`) – only used if
 * `SINGLE` is set
 * @param transactionOutputs the serialization of output amounts and locking
 * bytecode values (A.K.A. `hashOutputs` with `SIGHASH_ALL`) – only used if
 * `ALL` is set
 * @param locktime the locktime of the transaction
 * @param signingSerializationType the signing serialization type of the
 * signature (A.K.A. `sighash` type)
 * @param forkId while a bitcoin-encoded signature only includes a single byte
 * to encode the signing serialization type, a 3-byte forkId can be appended to
 * provide replay-protection between different forks. (See Bitcoin Cash's Replay
 * Protected Sighash spec for details.)
 */
exports.generateSigningSerializationBCH = (sha256, version, transactionOutpoints, transactionSequenceNumbers, outpointTransactionHash, outpointIndex, coveredBytecode, outputValue, sequenceNumber, correspondingOutput, transactionOutputs, locktime, signingSerializationType, forkId = new Uint8Array([0, 0, 0])) => new Uint8Array([
    ...utils_1.numberToBinUint32LE(version),
    ...exports.hashPrevouts(sha256, signingSerializationType, transactionOutpoints),
    ...exports.hashSequence(sha256, signingSerializationType, transactionSequenceNumbers),
    ...outpointTransactionHash.slice().reverse(),
    ...utils_1.numberToBinUint32LE(outpointIndex),
    ...Uint8Array.from([
        ...utils_1.bigIntToBitcoinVarInt(BigInt(coveredBytecode.length)),
        ...coveredBytecode
    ]),
    ...utils_1.bigIntToBinUint64LE(outputValue),
    ...utils_1.numberToBinUint32LE(sequenceNumber),
    ...exports.hashOutputs(sha256, signingSerializationType, transactionOutputs, correspondingOutput),
    ...utils_1.numberToBinUint32LE(locktime),
    ...signingSerializationType,
    ...forkId
]);
/**
 * @param signingSerializationType the 32-bit number indicating the signing
 * serialization algorithm to use
 */
exports.isLegacySigningSerialization = (signingSerializationType) => {
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const forkValue = signingSerializationType >> 8;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const newForkValue = (forkValue ^ 0xdead) | 0xff0000;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const sighashType = (newForkValue << 8) | (signingSerializationType & 0xff);
    // eslint-disable-next-line no-bitwise
    return (sighashType & SigningSerializationFlag.fork_id) === 0;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmluZy1zZXJpYWxpemF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9hdXRoL2luc3RydWN0aW9uLXNldHMvY29tbW9uL3NpZ25pbmctc2VyaWFsaXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGdEQUk4QjtBQUU5Qiw4QkFBOEI7QUFDOUI7O0dBRUc7QUFDSCxJQUFZLHdCQWtCWDtBQWxCRCxXQUFZLHdCQUF3QjtJQUNsQzs7T0FFRztJQUNILHFGQUFrQixDQUFBO0lBQ2xCOztPQUVHO0lBQ0gsbUZBQWlCLENBQUE7SUFDakI7O09BRUc7SUFDSCx1R0FBMkIsQ0FBQTtJQUMzQiw4RUFBYyxDQUFBO0lBQ2Q7O09BRUc7SUFDSCx5RkFBbUIsQ0FBQTtBQUNyQixDQUFDLEVBbEJXLHdCQUF3QixHQUF4QixnQ0FBd0IsS0FBeEIsZ0NBQXdCLFFBa0JuQztBQVFZLFFBQUEsaUNBQWlDLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRTtJQUNoRSxNQUFNLFFBQVE7SUFDWixzQ0FBc0M7SUFDdEMsSUFBSTtRQUNKLHNDQUFzQztRQUN0QyxDQUFDLENBQUMsd0JBQXdCLENBQUMsT0FBTyxHQUFHLHdCQUF3QixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlFLE9BQU8sQ0FDTCxRQUFRLElBQUksd0JBQXdCLENBQUMsV0FBVztRQUNoRCxRQUFRLElBQUksd0JBQXdCLENBQUMsb0JBQW9CLENBQzFELENBQUM7QUFDSixDQUFDLENBQUM7QUFFRixNQUFNLEtBQUssR0FBRyxDQUFDLElBQWdCLEVBQUUsSUFBOEIsRUFBRSxFQUFFO0FBQ2pFLHNDQUFzQztBQUN0QyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFekIsTUFBTSxNQUFNLEdBQUcsQ0FDYixJQUFnQixFQUNoQixJQUE4QjtBQUM5QixzQ0FBc0M7RUFDdEMsRUFBRSxD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