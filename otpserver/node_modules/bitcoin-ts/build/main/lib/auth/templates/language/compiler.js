"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../../crypto/crypto");
const utils_1 = require("../../../utils/utils");
const signing_serialization_1 = require("../../instruction-sets/common/signing-serialization");
const instruction_sets_1 = require("../../instruction-sets/instruction-sets");
const compile_1 = require("./compile");
const resolve_1 = require("./resolve");
/* eslint-disable camelcase */
var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs"] = "all_outputs";
    /**
     * A.K.A. `SIGHASH_ALL|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs_single_input"] = "all_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output"] = "corresponding_output";
    /**
     * A.K.A. `SIGHASH_SINGLE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output_single_input"] = "corresponding_output_single_input";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs"] = "no_outputs";
    /**
     * A.K.A `SIGHASH_NONE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs_single_input"] = "no_outputs_single_input";
})(SigningSerializationAlgorithmIdentifier = exports.SigningSerializationAlgorithmIdentifier || (exports.SigningSerializationAlgorithmIdentifier = {}));
var ScriptGenerationError;
(function (ScriptGenerationError) {
    ScriptGenerationError["missingVm"] = "An evaluation is required, but no VM was provided.";
    ScriptGenerationError["missingSha256"] = "Sha256 is required, but no implementation was provided.";
    ScriptGenerationError["missingSecp256k1"] = "Secp256k1 is required, but no implementation was provided.";
})(ScriptGenerationError || (ScriptGenerationError = {}));
// eslint-disable-next-line complexity
const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
    switch (algorithmIdentifier) {
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.all_outputs | signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.all_outputs |
                signing_serialization_1.SigningSerializationFlag.single_input |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.corresponding_output |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.corresponding_output |
                signing_serialization_1.SigningSerializationFlag.single_input |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.no_outputs | signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.no_outputs |
                signing_serialization_1.SigningSerializationFlag.single_input |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        default:
            return undefined;
    }
};
var SignatureIdentifierConstants;
(function (SignatureIdentifierConstants) {
    SignatureIdentifierConstants[SignatureIdentifierConstants["variableIdIndex"] = 0] = "variableIdIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["signingTargetIndex"] = 2] = "signingTargetIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["expectedSegments"] = 3] = "expectedSegments";
})(SignatureIdentifierConstants || (SignatureIdentifierConstants = {}));
exports.compilerOperationBCHGenerateSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid signature identifier. Signatures must be of the form: "[variable_id].${name}.[signing_serialization_type]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const algorithm = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingSerializationType = getSigningSerializationType(algorithm);
    if (signingSerializationType === undefined) {
        return `Unknown signing serialization algorithm, "${algorithm}".`;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { operationData } = data;
        if (operationData === undefined) {
            return `Could not construct the signature "${identifier}", signing serialization data was not provided in the compilation data.`;
        }
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const serialization = signing_serialization_1.generateSigningSerializationBCH(sha256, operationData.version, operationData.transactionOutpoints, operationData.transactionSequenceNumbers, operationData.outpointTransactionHash, operationData.outpointIndex, operationData.coveredBytecode, operationData.outputValue, operationData.sequenceNumber, operationData.correspondingOutput, operationData.transactionOutputs, operationData.locktime, signingSerializationType);
        const digest = sha256.hash(sha256.hash(serialization));
        const bitcoinEncodedSignature = Uint8Array.from([
            ...signingAlgorithm(secp256k1)(privateKey, digest),
            ...signingSerializationType
        ]);
        return bitcoinEncodedSignature;
    }
    return `Identifier "${identifier}" refers to a signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
exports.compilerOperationBCHGenerateDataSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${name}.[target_script_id]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const scriptId = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingTarget = environment.scripts[scriptId];
    const compiledTarget = resolve_1.resolveScriptIdentifier(scriptId, data, environment);
    if (signingTarget === undefined || compiledTarget === false) {
        return `Data signature tried to sign an unknown target script, "${scriptId}".`;
    }
    if (typeof compiledTarget === 'string') {
        return compiledTarget;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const digest = sha256.hash(compiledTarget.bytecode);
        return signingAlgorithm(secp256k1)(privateKey, digest);
    }
    return `Identifier "${identifier}" refers to a data signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
var SigningSerializationIdentifierConstants;
(function (SigningSerializationIdentifierConstants) {
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["operationIndex"] = 1] = "operationIndex";
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["expectedSegments"] = 2] = "expectedSegments";
})(SigningSerializationIdentifierConstants || (SigningSerializationIdentifierConstants = {}));
// eslint-disable-next-line complexity
exports.compilerOperationBCHGenerateSigningSerialization = (identifier, data, environment) => {
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !==
        SigningSerializationIdentifierConstants.expectedSegments) {
        return `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version" or "signing_serialization.all_outputs".`;
    }
    const algorithmOrComponent = identifierSegments[SigningSerializationIdentifierConstants.operationIndex];
    const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
    const { operationData } = data;
    if (operationData === undefined) {
        return `Could not construct the signing serialization "${identifier}", signing serialization data was not provided in the compilation data.`;
    }
    const { sha256 } = environment;
    if (sha256 === undefined) {
        return ScriptGenerationError.missingSha256;
    }
    // eslint-disable-next-line functional/no-conditional-statement
    if (signingSerializationType === undefined) {
        switch (algorithmOrComponent) {
            case 'corresponding_output':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : operationData.correspondingOutput;
            case 'corresponding_output_hash':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : sha256.hash(sha256.hash(operationData.correspondingOutput));
            case 'covered_bytecode_prefix':
                return utils_1.bigIntToBitcoinVarInt(BigInt(operationData.coveredBytecode.length));
            case 'covered_bytecode':
                return operationData.coveredBytecode;
            case 'locktime':
                return utils_1.numberToBinUint32LE(operationData.locktime);
            case 'outpoint_index':
                return utils_1.numberToBinUint32LE(operationData.outpointIndex);
            case 'outpoint_transaction_hash':
                return operationData.outpointTransactionHash;
            case 'output_value':
                return utils_1.bigIntToBinUint64LE(operationData.outputValue);
            case 'sequence_number':
                return utils_1.numberToBinUint32LE(operationData.sequenceNumber);
            case 'transaction_outpoints':
                return operationData.transactionOutpoints;
            case 'transaction_outpoints_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutpoints));
            case 'transaction_outputs':
                return operationData.transactionOutputs;
            case 'transaction_outputs_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutputs));
            case 'transaction_sequence_numbers':
                return operationData.transactionSequenceNumbers;
            case 'transaction_sequence_numbers_hash':
                return sha256.hash(sha256.hash(operationData.transactionSequenceNumbers));
            case 'version':
                return utils_1.numberToBinUint32LE(operationData.version);
            default:
                return `Unknown signing serialization algorithm or component, "${algorithmOrComponent}".`;
        }
    }
    return signing_serialization_1.generateSigningSerializationBCH(sha256, operationData.version, operationData.transactionOutpoints, operationData.transactionSequenceNumbers, operationData.outpointTransactionHash, operationData.outpointIndex, operationData.coveredBytecode, operationData.outputValue, operationData.sequenceNumber, operationData.correspondingOutput, operationData.transactionOutputs, operationData.locktime, signingSerializationType);
};
/* eslint-disable camelcase */
exports.getCompilerOperationsBCH = () => ({
    Key: {
        data_signature: exports.compilerOperationBCHGenerateDataSignature('data_signature', secp256k1 => secp256k1.signMessageHashDER),
        // eslint-disable-next-line complexity
        public_key: (identifier, data, environment) => {
            const { keys } = data;
            const { publicKeys, privateKeys } = keys;
            const [variableId] = identifier.split('.');
            if (publicKeys !== undefined &&
                publicKeys[variableId] !== undefined) {
                return publicKeys[variableId];
            }
            if (privateKeys !== undefined &&
                privateKeys[variableId] !== undefined) {
                const { secp256k1 } = environment;
                return secp256k1 === undefined
                    ? ScriptGenerationError.missingSecp256k1
                    : secp256k1.derivePublicKeyCompressed(privateKeys[variableId]);
            }
            return `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`;
        },
        schnorr_data_signature: exports.compilerOperationBCHGenerateDataSignature('schnorr_data_signature', secp256k1 => secp256k1.signMessageHashSchnorr),
        schnorr_signature: exports.compilerOperationBCHGenerateSignature('schnorr_signature', secp256k1 => secp256k1.signMessageHashSchnorr),
        signature: exports.compilerOperationBCHGenerateSignature('signature', secp256k1 => secp256k1.signMessageHashDER)
    },
    SigningSerialization: {
        corresponding_output: exports.compilerOperationBCHGenerateSigningSerialization,
        corresponding_output_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode: exports.compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode_prefix: exports.compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs: exports.compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs_single_input: exports.compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output: exports.compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output_single_input: exports.compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs: exports.compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs_single_input: exports.compilerOperationBCHGenerateSigningSerialization,
        locktime: exports.compilerOperationBCHGenerateSigningSerialization,
        outpoint_index: exports.compilerOperationBCHGenerateSigningSerialization,
        outpoint_transaction_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        output_value: exports.compilerOperationBCHGenerateSigningSerialization,
        sequence_number: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        version: exports.compilerOperationBCHGenerateSigningSerialization
    }
});
/**
 * TODO: describe
 * @param compilationEnvironment the environment from which to create the compiler
 */
exports.createCompiler = (compilationEnvironment) => ({
    debug: (script, data) => compile_1.compileScript(script, data, compilationEnvironment),
    generate: (script, data) => {
        const result = compile_1.compileScript(script, data, compilationEnvironment);
        return result.success
            ? { bytecode: result.bytecode, success: true }
            : { errorType: result.errorType, errors: result.errors, success: false };
    }
});
exports.createStateCompilerBCH = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
instructions) => instruction_sets_1.createAuthenticationProgramStateCommon(instructions, [], instruction_sets_1.createAuthenticationProgramExternalStateCommonEmpty());
/**
 * TODO: describe
 *
 * @param overrides a compilation environment from which properties will be used
 * to override properties of the default BCH environment
 */
exports.createCompilerBCH = async (overrides) => {
    const [sha256, secp256k1, vm] = await Promise.all([
        crypto_1.instantiateSha256(),
        crypto_1.instantiateSecp256k1(),
        instruction_sets_1.instantiateVirtualMachineBCH(instruction_sets_1.instructionSetBCHCurrentStrict)
    ]);
    return exports.createCompiler(Object.assign({
        createState: exports.createStateCompilerBCH,
        opcodes: instruction_sets_1.generateBytecodeMap(instruction_sets_1.OpcodesBCH),
        operations: exports.getCompilerOperationsBCH(),
        secp256k1,
        sha256,
        vm
    }, overrides));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvdGVtcGxhdGVzL2xhbmd1YWdlL2NvbXBpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbURBSWdDO0FBQ2hDLGdEQUk4QjtBQUM5QiwrRkFHNkQ7QUFDN0QsOEVBUWlEO0FBSWpELHVDQUErRTtBQUMvRSx1Q0FJbUI7QUF1Qm5CLDhCQUE4QjtBQUM5QixJQUFZLHVDQXlCWDtBQXpCRCxXQUFZLHVDQUF1QztJQUNqRDs7T0FFRztJQUNILHNFQUEyQixDQUFBO0lBQzNCOztPQUVHO0lBQ0gsZ0dBQXFELENBQUE7SUFDckQ7O09BRUc7SUFDSCx3RkFBNkMsQ0FBQTtJQUM3Qzs7T0FFRztJQUNILGtIQUF1RSxDQUFBO0lBQ3ZFOztPQUVHO0lBQ0gsb0VBQXlCLENBQUE7SUFDekI7O09BRUc7SUFDSCw4RkFBbUQsQ0FBQTtBQUNyRCxDQUFDLEVBekJXLHVDQUF1QyxHQUF2QywrQ0FBdUMsS0FBdkMsK0NBQXVDLFFBeUJsRDtBQXFDRCxJQUFLLHFCQUlKO0FBSkQsV0FBSyxxQkFBcUI7SUFDeEIseUZBQWdFLENBQUE7SUFDaEUsa0dBQXlFLENBQUE7SUFDekUsd0dBQStFLENBQUE7QUFDakYsQ0FBQyxFQUpJLHFCQUFxQixLQUFyQixxQkFBcUIsUUFJekI7QUFFRCxzQ0FBc0M7QUFDdEMsTUFBTSwyQkFBMkIsR0FBRyxDQUNsQyxtQkFBMkIsRUFDM0IsTUFBTSxHQUFHLEVBQUUsRUFDWCxFQUFFO0lBQ0YsUUFBUSxtQkFBbUIsRUFBRTtRQUMzQixLQUFLLEdBQUcsTUFBTSxHQUFHLHVDQUF1QyxDQUFDLFdBQVcsRUFBRTtZQUNwRSxPQUFPLFVBQVUsQ0FBQyxFQUFFO1lBQ2xCLHNDQUFzQztZQUN0QyxnREFBd0IsQ0FBQyxXQUFXLEdBQUcsZ0RBQXdCLENBQUMsT0FBTyxDQUN4RSxDQUFDO1FBQ0osS0FBSyxHQUFHLE1B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