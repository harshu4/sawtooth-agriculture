/* eslint-disable functional/no-expression-statement, functional/no-let, init-declarations */
import { randomBytes } from 'crypto';
import test from 'ava';
import suite from 'chuhai';
import * as elliptic from 'elliptic';
import * as secp256k1Node from 'secp256k1';
import { binToHex } from '../utils/hex';
import { instantiateSecp256k1 } from './secp256k1';
const secp256k1Promise = instantiateSecp256k1();
const privKeyLength = 32;
const getValidPrivateKey = (secp256k1) => {
    let privKey;
    // eslint-disable-next-line functional/no-loop-statement
    do {
        privKey = randomBytes(privKeyLength);
    } while (!secp256k1.validatePrivateKey(privKey));
    return privKey;
};
const setup = async () => ({
    ellipticEc: new elliptic.ec('secp256k1'),
    secp256k1: await secp256k1Promise
});
/**
 * Note: elliptic doesn't document an equivalent to verifySignatureDERLowS, so
 * these benchmarks slightly overestimate elliptic's performance in applications
 * where Low-S verification is required (i.e. Bitcoin).
 *
 * We also help secp256k1-node a bit by converting each of it's inputs into
 * Node.js `Buffer` objects. So its performance here is a best case.
 */
test('bench: secp256k1: verify signature Low-S, uncompressed pubkey', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await suite(t.title, s => {
        let messageHash;
        let pubkeyUncompressed;
        let sigDER;
        let result;
        let ellipticPublicKey;
        const nextCycle = () => {
            const privKey = getValidPrivateKey(secp256k1);
            messageHash = randomBytes(privKeyLength);
            pubkeyUncompressed = secp256k1.derivePublicKeyUncompressed(privKey);
            ellipticPublicKey = ellipticEc.keyFromPublic(binToHex(pubkeyUncompressed), 'hex');
            sigDER = secp256k1.signMessageHashDER(privKey, messageHash);
            result = false;
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            result = secp256k1.verifySignatureDERLowS(sigDER, pubkeyUncompressed, messageHash);
        });
        s.bench('elliptic', () => {
            result = ellipticEc
                .keyFromPublic(ellipticPublicKey)
                .verify(messageHash, sigDER);
        });
        s.bench('secp256k1-node', () => {
            result = secp256k1Node.ecdsaVerify(secp256k1Node.signatureImport(sigDER), messageHash, pubkeyUncompressed);
        });
        s.cycle(() => {
            t.true(result);
            nextCycle();
        });
    });
});
test('bench: secp256k1: verify signature Low-S, compressed pubkey', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await suite(t.title, s => {
        let messageHash;
        let pubkeyCompressed;
        let sigDER;
        let result;
        let ellipticPublicKey;
        const nextCycle = () => {
            const privKey = getValidPrivateKey(secp256k1);
            messageHash = randomBytes(privKeyLength);
            pubkeyCompressed = secp256k1.derivePublicKeyCompressed(privKey);
            ellipticPublicKey = ellipticEc.keyFromPublic(binToHex(pubkeyCompressed), 'hex');
            sigDER = secp256k1.signMessageHashDER(privKey, messageHash);
            result = false;
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            result = secp256k1.verifySignatureDERLowS(sigDER, pubkeyCompressed, messageHash);
        });
        s.bench('elliptic', () => {
            result = ellipticEc
                .keyFromPublic(ellipticPublicKey)
                .verify(messageHash, sigDER);
        });
        s.bench('secp256k1-node', () => {
            result = secp256k1Node.ecdsaVerify(secp256k1Node.signatureImport(sigDER), messageHash, pubkeyCompressed);
        });
        s.cycle(() => {
            t.true(result);
            nextCycle();
        });
    });
});
test('bench: secp256k1: derive compressed pubkey', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await suite(t.title, s => {
        let privKey;
        let pubkeyCompressedExpected;
        let pubkeyCompressedBenchmark;
        const nextCycle = () => {
            privKey = getValidPrivateKey(secp256k1);
            pubkeyCompressedExpected = secp256k1.derivePublicKeyCompressed(privKey);
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            pubkeyCompressedBenchmark = secp256k1.derivePublicKeyCompressed(privKey);
        });
        s.bench('elliptic', () => {
            pubkeyCompressedBenchmark = Uint8Array.from(ellipticEc
                .keyFromPrivate(privKey)
                .getPublic()
                .encodeCompressed());
        });
        s.bench('secp256k1-node', () => {
            pubkeyCompressedBenchmark = secp256k1Node.publicKeyCreate(privKey, true);
        });
        s.cycle(() => {
            t.deepEqual(pubkeyCompressedExpected, pubkeyCompressedBenchmark);
            nextCycle();
        });
    });
});
test('bench: secp256k1: create DER Low-S signature', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await suite(t.title, s => {
        let privKey;
        let messageHash;
        let sigDERExpected;
        let sigDERBenchmark;
        const nextCycle = () => {
            privKey = getValidPrivateKey(secp256k1);
            messageHash = randomBytes(privKeyLength);
            sigDERExpected = secp256k1.signMessageHashDER(privKey, messageHash);
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            sigDERBenchmark = secp256k1.signMessageHashDER(privKey, messageHash);
        });
        s.bench('elliptic', () => {
            sigDERBenchmark = ellipticEc
                .keyFromPrivate(privKey)
                .sign(messageHash)
                .toDER();
        });
        s.bench('secp256k1-node', () => {
            sigDERBenchmark = secp256k1Node.signatureExport(secp256k1Node.ecdsaSign(messageHash, privKey).signature);
        });
        s.cycle(() => {
            /**
             * Since Elliptic doesn't document a way to create Low-S signatures, we
             * normalize the results to validate them. This may overestimate
             * Elliptic's performance slightly.
             */
            t.deepEqual(sigDERExpected, secp256k1.normalizeSignatureDER(new Uint8Array(sigDERBenchmark)));
            nextCycle();
        });
    });
});
test('bench: secp256k1: sign: Schnorr vs. ECDSA', async (t) => {
    const { secp256k1 } = await setup();
    await suite(t.title, s => {
        let privKey;
        let messageHash;
        let sigDERExpected;
        let sigDERBenchmark;
        let sigSchnorrExpected;
        let sigSchnorrBenchmark;
        let isSchnorr;
        const nextCycle = () => {
            privKey = getValidPrivateKey(secp256k1);
            messageHash = randomBytes(privKeyLength);
            sigDERExpected = secp256k1.signMessageHashDER(privKey, messageHash);
            sigSchnorrExpected = secp256k1.signMessageHashSchnorr(privKey, messageHash);
        };
        nextCycle();
        s.bench('secp256k1.signMessageHashDER', () => {
            isSchnorr = false;
            sigDERBenchmark = secp256k1.signMessageHashDER(privKey, messageHash);
        });
        s.bench('secp256k1.signMessageHashSchnorr', () => {
            isSchnorr = true;
            sigSchnorrBenchmark = secp256k1.signMessageHashSchnorr(privKey, messageHash);
        });
        s.cycle(() => {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            isSchnorr
                ? t.deepEqual(sigSchnorrExpected, sigSchnorrBenchmark)
                : t.deepEqual(sigDERExpected, sigDERBenchmark);
            nextCycle();
        });
    });
});
test('bench: secp256k1: verify: Schnorr vs. ECDSA', async (t) => {
    const { secp256k1 } = await setup();
    await suite(t.title, s => {
        let messageHash;
        let pubkeyCompressed;
        let sigDER;
        let sigSchnorr;
        let result;
        const nextCycle = () => {
            const privKey = getValidPrivateKey(secp256k1);
            messageHash = randomBytes(privKeyLength);
            pubkeyCompressed = secp256k1.derivePublicKeyCompressed(privKey);
            sigDER = secp256k1.signMessageHashDER(privKey, messageHash);
            sigSchnorr = secp256k1.signMessageHashSchnorr(privKey, messageHash);
            result = false;
        };
        nextCycle();
        s.bench('secp256k1.verifySignatureDERLowS (ECDSA, pubkey compressed)', () => {
            result = secp256k1.verifySignatureDERLowS(sigDER, pubkeyCompressed, messageHash);
        });
        s.bench('secp256k1.verifySignatureSchnorr (Schnorr, pubkey compressed)', () => {
            result = secp256k1.verifySignatureSchnorr(sigSchnorr, pubkeyCompressed, messageHash);
        });
        s.cycle(() => {
            t.true(result);
            nextCycle();
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmJlbmNoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jcnlwdG8vc2VjcDI1NmsxLmJlbmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZGQUE2RjtBQUM3RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXJDLE9BQU8sSUFBSSxNQUFNLEtBQUssQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxRQUFRLENBQUM7QUFDM0IsT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVLENBQUM7QUFDckMsT0FBTyxLQUFLLGFBQWEsTUFBTSxXQUFXLENBQUM7QUFFM0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUV4QyxPQUFPLEVBQUUsb0JBQW9CLEVBQWEsTUFBTSxhQUFhLENBQUM7QUFFOUQsTUFBTSxnQkFBZ0IsR0FBRyxvQkFBb0IsRUFBRSxDQUFDO0FBQ2hELE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUN6QixNQUFNLGtCQUFrQixHQUFHLENBQUMsU0FBb0IsRUFBYyxFQUFFO0lBQzlELElBQUksT0FBbUIsQ0FBQztJQUN4Qix3REFBd0Q7SUFDeEQsR0FBRztRQUNELE9BQU8sR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDdEMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUNqRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRixNQUFNLEtBQUssR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUM7SUFDekIsVUFBVSxFQUFFLElBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7SUFDeEMsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCO0NBQ2xDLENBQUMsQ0FBQztBQUVIOzs7Ozs7O0dBT0c7QUFDSCxJQUFJLENBQUMsK0RBQStELEVBQUUsS0FBSyxFQUFDLENBQUMs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