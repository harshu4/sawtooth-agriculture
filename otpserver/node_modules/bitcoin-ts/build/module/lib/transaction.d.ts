import { Sha256 } from './crypto/sha256';
/**
 * Data type representing a Transaction Input.
 */
export interface Input {
    /**
     * The index of the output in the transaction from which this input is spent.
     *
     * An "outpoint" is a reference ("pointer") to an output in a previous
     * transaction.
     */
    outpointIndex: number;
    /**
     * A.K.A. `Transaction ID`
     *
     * The hash of the raw transaction from which this input is spent in
     * big-endian byte order.
     *
     * @remarks
     * An "outpoint" is a reference (A.K.A. "pointer") to an output in a previous
     * transaction.
     *
     * TODO: clarify: in what order to block explorers display hashes? In what
     * order are hashes serialized?
     *
     * Serialized raw bitcoin transactions encode this value in little-endian byte
     * order. However, it is more common to use big-endian byte order when
     * displaying transaction hashes. (In part because the SHA-256 specification
     * defines its output as big-endian, so this byte order is output by most
     * cryptographic libraries.)
     */
    outpointTransactionHash: Uint8Array;
    /**
     * TODO: summarize BIP 68
     */
    sequenceNumber: number;
    /**
     * The bytecode used to unlock a transaction output. To spend an output,
     * unlocking bytecode must be included in a transaction input which – when
     * evaluated in the authentication virtual machine with the locking bytecode –
     * completes in valid state.
     *
     * A.K.A. `scriptSig` or "unlocking script"
     */
    unlockingBytecode: Uint8Array;
}
/**
 * Data type representing a Transaction Output.
 */
export interface Output {
    /**
     * The bytecode used to encumber a transaction output. To spend the output,
     * unlocking bytecode must be included in a transaction input which – when
     * evaluated with the locking bytecode – completes in valid state.
     *
     * A.K.A. `scriptPubKey` or "locking script"
     */
    readonly lockingBytecode: Uint8Array;
    /**
     * The value of the output in satoshis, the smallest unit of bitcoin. There
     * are 100 satoshis in a bit, and 100,000,000 satoshis in a bitcoin.
     */
    readonly satoshis: bigint;
}
/**
 * Data type representing a Transaction.
 */
export interface Transaction {
    /**
     * An array of inputs included in this transaction.
     *
     * Input order is critical to signing serializations, and reordering inputs
     * may invalidate transactions.
     */
    inputs: Input[];
    /**
     * The locktime at which this transaction is considered valid.
     *
     * Locktime can be provided as either a timestamp or a block height. Values
     * less than `500000000` are understood to be a block height (the current
     * block number in the chain, beginning from block 0). Values greater than or
     * equal to `500000000` are understood to be a UNIX timestamp.
     *
     * For validating timestamp values, the median timestamp of the last 11 blocks
     * is used. The precise behavior is defined in BIP113.
     *
     * If the `sequenceNumber` of every transaction input is set to `0xffffffff`
     * (4294967295), locktime is ignored, and the transaction may be added to a
     * block (even if the specified locktime has not yet been reached).
     */
    locktime: number;
    /**
     * An array of outputs included in this transaction.
     *
     * Output order is critical to signing serializations, and reordering outputs
     * may invalidate transactions.
     */
    outputs: Output[];
    /**
     * The version of this transaction. Since BIP68, most transactions use a
     * version of `2`.
     */
    version: number;
}
/**
 * @param bin the raw transaction from which to read the input
 * @param offset the offset at which the input begins
 */
export declare const readTransactionInput: (bin: Uint8Array, offset: number) => {
    input: {
        outpointIndex: number;
        outpointTransactionHash: Uint8Array;
        sequenceNumber: number;
        unlockingBytecode: Uint8Array;
    };
    nextOffset: number;
};
/**
 * Serialize a single input.
 * @param output the input to serialize
 */
export declare const serializeInput: (input: Input) => Uint8Array;
/**
 * Serialize a set of inputs for inclusion in a serialized transaction.
 *
 * Format: <BitcoinVarInt: input count> <serialized inputs>
 *
 * @param inputs the set of inputs to serialize
 */
export declare const serializeInputs: (inputs: readonly Input[]) => Uint8Array;
/**
 * @param bin the raw transaction from which to read the output
 * @param offset the offset at which the output begins
 */
export declare const readTransactionOutput: (bin: Uint8Array, offset: number) => {
    nextOffset: number;
    output: {
        lockingBytecode: Uint8Array;
        satoshis: bigint;
    };
};
/**
 * Serialize a single output.
 * @param output the output to serialize
 */
export declare const serializeOutput: (output: Output) => Uint8Array;
/**
 * Serialize a set of outputs for inclusion in a serialized transaction.
 *
 * Format: <BitcoinVarInt: output count> <serialized outputs>
 *
 * @param outputs the set of outputs to serialize
 */
export declare const serializeOutputsForTransaction: (outputs: readonly Output[]) => Uint8Array;
/**
 * TODO: document return type (note outpointTransactionHash is little-endian – most UIs display big-endian transaction hashes)
 *
 * Note: this method throws runtime errors when attempting to decode improperly
 * encoded transactions.
 *
 * @param bin the raw transaction to decode
 */
export declare const deserializeTransaction: (bin: Uint8Array) => Transaction;
/**
 * TODO: doc
 */
export declare const serializeTransaction: (tx: Transaction) => Uint8Array;
/**
 * Derive a standard identifier from a serialized data structure.
 *
 * @remarks
 * By convention, Bitcoin transaction and block identifiers are derived by
 * double-sha256 hashing their serialized form, and reversing the byte order.
 * (The result of sha256 is defined by its specification as big-endian, and
 * bitcoin displays hashes in little-endian format.)
 *
 * @returns an identifier in little-endian byte order
 *
 * @param data the serialized raw data being identified
 * @param sha256 an implementation of sha256
 */
export declare const getBitcoinIdentifier: (data: Uint8Array, sha256: Sha256) => Uint8Array;
/**
 * Derive a standard transaction identifier from a serialized transaction.
 *
 * @returns a Transaction ID in little-endian byte order
 *
 * @param transaction the serialized transaction
 * @param sha256 an implementation of sha256
 */
export declare const getBitcoinTransactionId: (transaction: Uint8Array, sha256: Sha256) => string;
/**
 * Get the hash of all outpoints in a series of inputs. (For use in
 * `hashTransactionOutpoints`.)
 *
 * @param inputs the series of inputs from which to extract the outpoints
 * @param sha256 an implementation of sha256
 */
export declare const serializeOutpoints: (inputs: readonly Input[]) => Uint8Array;
/**
 * Get the signing serialization for a series of outputs.
 * @param outputs the series of outputs to serialize
 */
export declare const serializeOutputsForSigning: (outputs: readonly Output[]) => Uint8Array;
/**
 * Serialize a series of input sequence numbers.
 *
 * @param inputs the series of inputs from which to extract the sequence numbers
 */
export declare const serializeSequenceNumbers: (inputs: readonly Input[]) => Uint8Array;
//# sourceMappingURL=transaction.d.ts.map