import { decodeBech32, encodeBech32, isBech32, regroupBits } from './bech32';
export var CashAddressNetworkPrefix;
(function (CashAddressNetworkPrefix) {
    CashAddressNetworkPrefix["mainnet"] = "bitcoincash";
    CashAddressNetworkPrefix["testnet"] = "bchtest";
    CashAddressNetworkPrefix["regtest"] = "bchreg";
})(CashAddressNetworkPrefix || (CashAddressNetworkPrefix = {}));
export const cashAddressBitToSize = {
    0: 160,
    1: 192,
    2: 224,
    3: 256,
    4: 320,
    5: 384,
    6: 448,
    7: 512
};
export const cashAddressSizeToBit = {
    160: 0,
    192: 1,
    224: 2,
    256: 3,
    320: 4,
    384: 5,
    448: 6,
    512: 7
};
/**
 * The CashAddress specification standardizes the format of the version byte:
 * - Most significant bit: reserved, must be `0`
 * - next 4 bits: Address Type
 * - 3 least significant bits: Hash Size
 *
 * Only two Address Type values are currently standardized:
 * - 0 (`0b0000`): P2PKH
 * - 1 (`0b0001`): P2SH
 *
 * While both P2PKH and P2SH addresses always use 160 bit hashes, the
 * CashAddress specification standardizes other sizes for future use (or use by
 * other systems), see `CashAddressSizeBit`.
 *
 * With these constraints, only two version byte values are currently standard.
 */
export var CashAddressVersionByte;
(function (CashAddressVersionByte) {
    /**
     * Pay to Public Key Hash (P2PKH): `0b00000000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0000` (P2PKH)
     * - Size bits: `000` (160 bits)
     */
    CashAddressVersionByte[CashAddressVersionByte["P2PKH"] = 0] = "P2PKH";
    /**
     * Pay to Script Hash (P2SH): `0b00001000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0001` (P2SH)
     * - Size bits: `000` (160 bits)
     */
    CashAddressVersionByte[CashAddressVersionByte["P2SH"] = 8] = "P2SH";
})(CashAddressVersionByte || (CashAddressVersionByte = {}));
/**
 * The address types currently defined in the CashAddress specification. See
 * also: `CashAddressVersionByte`.
 */
export var CashAddressType;
(function (CashAddressType) {
    /**
     * Pay to Public Key Hash (P2PKH)
     */
    CashAddressType[CashAddressType["P2PKH"] = 0] = "P2PKH";
    /**
     * Pay to Script Hash (P2SH)
     */
    CashAddressType[CashAddressType["P2SH"] = 1] = "P2SH";
})(CashAddressType || (CashAddressType = {}));
const cashAddressTypeBitShift = 3;
/**
 * Encode a CashAddress version byte for the given address type and hash length.
 * See `CashAddressVersionByte` for more information.
 *
 * The `type` parameter must be a number between `0` and `15`, and `bitLength`
 * must be one of the standardized lengths. To use the contents of a variable,
 * cast it to `CashAddressType` or `CashAddressSize` respectively, e.g.:
 * ```ts
 * const type = 3 as CashAddressType;
 * const size = 160 as CashAddressSize;
 * getCashAddressVersionByte(type, size);
 * ```
 * @param type the address type of the hash being encoded
 * @param bitLength the bit length of the hash being encoded
 */
export const encodeCashAddressVersionByte = (type, bitLength
// eslint-disable-next-line no-bitwise
) => (type << cashAddressTypeBitShift) | cashAddressSizeToBit[bitLength];
const cashAddressReservedBitMask = 0b10000000;
const cashAddressTypeBits = 0b1111;
const cashAddressSizeBits = 0b111;
const empty = 0;
export var CashAddressVersionByteDecodingError;
(function (CashAddressVersionByteDecodingError) {
    CashAddressVersionByteDecodingError["reservedBitSet"] = "Reserved bit is set.";
})(CashAddressVersionByteDecodingError || (CashAddressVersionByteDecodingError = {}));
/**
 * Decode a CashAddress version byte.
 * @param version the version byte to decode
 */
export const decodeCashAddressVersionByte = (version) => 
// eslint-disable-next-line no-negated-condition, no-bitwise
(version & cashAddressReservedBitMask) !== empty
    ? CashAddressVersionByteDecodingError.reservedBitSet
    : {
        bitLength: cashAddressBitToSize[
        // eslint-disable-next-line no-bitwise
        (version & cashAddressSizeBits)],
        // eslint-disable-next-line no-bitwise
        type: (version >>> cashAddressTypeBitShift) & cashAddressTypeBits
    };
/**
 * In ASCII, each pair of upper and lower case characters share the same 5 least
 * significant bits.
 */
const asciiCaseInsensitiveBits = 0b11111;
/**
 * Convert a string into an array of 5-bit numbers, representing the
 * characters in a case-insensitive way.
 * @param prefix the prefix to mask
 */
export const maskCashAddressPrefix = (prefix) => {
    const result = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < prefix.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
        result.push(prefix.charCodeAt(i) & asciiCaseInsensitiveBits);
    }
    return result;
};
// prettier-ignore
const bech32GeneratorMostSignificantByte = [0x98, 0x79, 0xf3, 0xae, 0x1e]; // eslint-disable-line @typescript-eslint/no-magic-numbers
// prettier-ignore
const bech32GeneratorRemainingBytes = [0xf2bc8e61, 0xb76d99e2, 0x3e5fb3c4, 0x2eabe2a8, 0x4f43e470]; // eslint-disable-line @typescript-eslint/no-magic-numbers
/**
 * Perform the CashAddress polynomial modulo operation, which is based on the
 * Bech32 polynomial modulo operation, but the returned checksum is 40 bits,
 * rather than 30.
 *
 * A.K.A. `PolyMod`
 *
 * @remarks
 * Notes from Bitcoin ABC:
 * This function will compute what 8 5-bit values to XOR into the last 8 input
 * values, in order to make the checksum 0. These 8 values are packed together
 * in a single 40-bit integer. The higher bits correspond to earlier values.
 *
 * The input is interpreted as a list of coefficients of a polynomial over F
 * = GF(32), with an implicit 1 in front. If the input is [v0,v1,v2,v3,v4],
 * that polynomial is v(x) = 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4.
 * The implicit 1 guarantees that [v0,v1,v2,...] has a distinct checksum
 * from [0,v0,v1,v2,...].
 *
 * The output is a 40-bit integer whose 5-bit groups are the coefficients of
 * the remainder of v(x) mod g(x), where g(x) is the cashaddr generator, x^8
 * + {19}*x^7 + {3}*x^6 + {25}*x^5 + {11}*x^4 + {25}*x^3 + {3}*x^2 + {19}*x
 * + {1}. g(x) is chosen in such a way that the resulting code is a BCH
 * code, guaranteeing detection of up to 4 errors within a window of 1025
 * characters. Among the various possible BCH codes, one was selected to in
 * fact guarantee detection of up to 5 errors within a window of 160
 * characters and 6 errors within a window of 126 characters. In addition,
 * the code guarantee the detection of a burst of up to 8 errors.
 *
 * Note that the coefficients are elements of GF(32), here represented as
 * decimal numbers between {}. In this finite field, addition is just XOR of
 * the corresponding numbers. For example, {27} + {13} = {27 ^ 13} = {22}.
 * Multiplication is more complicated, and requires treating the bits of
 * values themselves as coefficients of a polynomial over a smaller field,
 * GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example,
 * {5} * {26} = (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 +
 * a^3 + a) = a^6 + a^5 + a^4 + a = a^3 + 1 (mod a^5 + a^3 + 1) = {9}.
 *
 * During the course of the loop below, `c` contains the bit-packed
 * coefficients of the polynomial constructed from just the values of v that
 * were processed so far, mod g(x). In the above example, `c` initially
 * corresponds to 1 mod (x), and after processing 2 inputs of v, it
 * corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the
 * starting value for `c`.
 *
 * @internalRemarks
 * Derived from the `bitcore-lib-cash` implementation, which does not require
 * BigInt: https://github.com/bitpay/bitcore
 *
 * @param v Array of 5-bit integers over which the checksum is to be computed
 */
export const cashAddressPolynomialModulo = (v) => {
    /* eslint-disable functional/no-let, functional/no-loop-statement, functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers */
    let mostSignificantByte = 0;
    let lowerBytes = 1;
    let c = 0;
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, no-plusplus
    for (let j = 0; j < v.length; j++) {
        c = mostSignificantByte >>> 3;
        mostSignificantByte &= 0x07;
        mostSignificantByte <<= 5;
        mostSignificantByte |= lowerBytes >>> 27;
        lowerBytes &= 0x07ffffff;
        lowerBytes <<= 5;
        lowerBytes ^= v[j];
        // eslint-disable-next-line no-plusplus
        for (let i = 0; i < bech32GeneratorMostSignificantByte.length; ++i) {
            // eslint-disable-next-line functional/no-conditional-statement, @typescript-eslint/strict-boolean-expressions
            if (c & (1 << i)) {
                mostSignificantByte ^= bech32GeneratorMostSignificantByte[i];
                lowerBytes ^= bech32GeneratorRemainingBytes[i];
            }
        }
    }
    lowerBytes ^= 1;
    // eslint-disable-next-line functional/no-conditional-statement
    if (lowerBytes < 0) {
        lowerBytes ^= 1 << 31;
        lowerBytes += (1 << 30) * 2;
    }
    return mostSignificantByte * (1 << 30) * 4 + lowerBytes;
    /* eslint-enable functional/no-let, functional/no-loop-statement, functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers */
};
const base32WordLength = 5;
const base256WordLength = 8;
/**
 * Convert the checksum returned by `cashAddressPolynomialModulo` to an array of
 * 5-bit positive integers which can be Base32 encoded.
 * @param checksum a 40 bit checksum returned by `cashAddressPolynomialModulo`
 */
export const cashAddressChecksumToUint5Array = (checksum) => {
    const result = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < base256WordLength; ++i) {
        // eslint-disable-next-line functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers, functional/immutable-data
        result.push(checksum & 31);
        // eslint-disable-next-line functional/no-expression-statement, @typescript-eslint/no-magic-numbers, no-param-reassign
        checksum /= 32;
    }
    // eslint-disable-next-line functional/immutable-data
    return result.reverse();
};
const payloadSeparator = 0;
/**
 * Encode a hash as a CashAddress-like string using the CashAddress format.
 *
 * To encode a standard CashAddress, use `encodeCashAddress`.
 *
 * @param prefix a valid prefix indicating the network for which to encode the
 * address – must be only lowercase letters
 * @param version a single byte indicating the version of this address
 * @param hash the hash to encode
 */
export const encodeCashAddressFormat = (prefix, version, hash) => {
    const checksum40BitPlaceholder = [0, 0, 0, 0, 0, 0, 0, 0];
    const payloadContents = regroupBits(Uint8Array.from([version, ...hash]), base256WordLength, base32WordLength);
    const checksumContents = [
        ...maskCashAddressPrefix(prefix),
        payloadSeparator,
        ...payloadContents,
        ...checksum40BitPlaceholder
    ];
    const checksum = cashAddressPolynomialModulo(checksumContents);
    const payload = [
        ...payloadContents,
        ...cashAddressChecksumToUint5Array(checksum)
    ];
    return `${prefix}:${encodeBech32(payload)}`;
};
export var CashAddressEncodingError;
(function (CashAddressEncodingError) {
    CashAddressEncodingError["unsupportedHashLength"] = "CashAddress encoding error: a hash of this length can not be encoded as a valid CashAddress.";
})(CashAddressEncodingError || (CashAddressEncodingError = {}));
const isValidBitLength = (bitLength) => cashAddressSizeToBit[bitLength] !== undefined;
/**
 * Encode a hash as a CashAddress.
 *
 * For other address standards which closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * `encodeCashAddressFormat`.
 *
 * @param prefix a valid prefix indicating the network for which to encode the
 * address (usually a `CashAddressNetworkPrefix`) – must be only lowercase
 * letters
 * @param type the `CashAddressType` to encode in the version byte – usually a
 * `CashAddressType`
 * @param hash the hash to encode (for P2PKH, the public key hash; for P2SH, the
 * redeeming bytecode hash)
 */
export const encodeCashAddress = (prefix, type, hash) => {
    const bitLength = hash.length * base256WordLength;
    if (!isValidBitLength(bitLength)) {
        return CashAddressEncodingError.unsupportedHashLength;
    }
    return encodeCashAddressFormat(prefix, encodeCashAddressVersionByte(type, bitLength), hash);
};
export var CashAddressDecodingError;
(function (CashAddressDecodingError) {
    CashAddressDecodingError["invalidFormat"] = "CashAddress decoding error: CashAddresses should be of the form \"prefix:payload\".";
    CashAddressDecodingError["malformedPayload"] = "CashAddress decoding error: the payload is not properly encoded.";
    CashAddressDecodingError["invalidChecksum"] = "CashAddress decoding error: please review the address for errors.";
    CashAddressDecodingError["reservedByte"] = "CashAddress decoding error: unknown CashAddress version, reserved byte set.";
    CashAddressDecodingError["mismatchedHashLength"] = "CashAddress decoding error: mismatched hash length for specified address version.";
})(CashAddressDecodingError || (CashAddressDecodingError = {}));
/**
 * Decode and validate a string using the CashAddress format. This is more
 * lenient than `decodeCashAddress`, which also validates the contents of the
 * version byte.
 *
 * Note, this method requires `address` to include a network prefix. To
 * decode a string with an unknown prefix, try
 * `decodeCashAddressFormatWithoutPrefix`.
 *
 * @param address the CashAddress-like string to decode
 */
// eslint-disable-next-line complexity
export const decodeCashAddressFormat = (address) => {
    const parts = address.toLowerCase().split(':');
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
        return CashAddressDecodingError.invalidFormat;
    }
    const [prefix, payload] = parts;
    if (!isBech32(payload)) {
        return CashAddressDecodingError.malformedPayload;
    }
    const decodedPayload = decodeBech32(payload);
    const polynomial = [
        ...maskCashAddressPrefix(prefix),
        payloadSeparator,
        ...decodedPayload
    ];
    if (cashAddressPolynomialModulo(polynomial) !== 0) {
        return CashAddressDecodingError.invalidChecksum;
    }
    const checksum40BitPlaceholderLength = 8;
    const payloadContents = regroupBits(decodedPayload.slice(0, -checksum40BitPlaceholderLength), base32WordLength, base256WordLength, false);
    if (typeof payloadContents === 'string') {
        return payloadContents;
    }
    const [version, ...hashContents] = payloadContents;
    const hash = Uint8Array.from(hashContents);
    return { hash, prefix, version };
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * For other address-like standards which closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * `decodeCashAddressFormat`.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * `decodeCashAddressFormatWithoutPrefix`.
 *
 * @param address the CashAddress to decode
 */
export const decodeCashAddress = (address) => {
    const decoded = decodeCashAddressFormat(address);
    if (typeof decoded === 'string') {
        return decoded;
    }
    const info = decodeCashAddressVersionByte(decoded.version);
    if (info === CashAddressVersionByteDecodingError.reservedBitSet) {
        return CashAddressDecodingError.reservedByte;
    }
    if (decoded.hash.length * base256WordLength !== info.bitLength) {
        return CashAddressDecodingError.mismatchedHashLength;
    }
    return {
        hash: decoded.hash,
        prefix: decoded.prefix,
        type: info.type
    };
};
/**
 * Attempt to decode and validate a CashAddress against a list of possible
 * prefixes. If the correct prefix is known, use `decodeCashAddress`.
 *
 * @param address the CashAddress to decode
 * @param possiblePrefixes the network prefixes to try
 */
// decodeCashAddressWithoutPrefix
export const decodeCashAddressFormatWithoutPrefix = (address, possiblePrefixes = [
    CashAddressNetworkPrefix.mainnet,
    CashAddressNetworkPrefix.testnet,
    CashAddressNetworkPrefix.regtest
]) => {
    // eslint-disable-next-line functional/no-loop-statement
    for (const prefix of possiblePrefixes) {
        const attempt = decodeCashAddressFormat(`${prefix}:${address}`);
        if (attempt !== CashAddressDecodingError.invalidChecksum) {
            return attempt;
        }
    }
    return CashAddressDecodingError.invalidChecksum;
};
const asciiLowerCaseStart = 96;
/**
 * Convert a CashAddress polynomial to CashAddress string format.
 *
 * @internalRemarks
 * CashAddress polynomials take the form:
 *
 * `[lowest 5 bits of each prefix character] 0 [payload + checksum]`
 *
 * This method remaps the 5-bit integers in the prefix location to the matching
 * ASCII lowercase characters, replaces the separator with `:`, and then Bech32
 * encodes the remaining payload and checksum.
 *
 * @param polynomial an array of 5-bit integers representing the terms of a
 * CashAddress polynomial
 */
export const cashAddressPolynomialToCashAddress = (polynomial) => {
    const separatorPosition = polynomial.indexOf(0);
    const prefix = polynomial
        .slice(0, separatorPosition)
        .map(integer => String.fromCharCode(asciiLowerCaseStart + integer))
        .join('');
    const contents = encodeBech32(polynomial.slice(separatorPosition + 1));
    return `${prefix}:${contents}`;
};
export var CashAddressCorrectionError;
(function (CashAddressCorrectionError) {
    CashAddressCorrectionError["tooManyErrors"] = "This address has more than 2 errors and cannot be corrected.";
})(CashAddressCorrectionError || (CashAddressCorrectionError = {}));
const finiteFieldOrder = 32;
/**
 * Attempt to correct up to 2 errors in a CashAddress. The CashAddress must be
 * properly formed (include a prefix and only contain Bech32 characters).
 *
 * ## **Improper use of this method carries the risk of lost funds.**
 *
 * It is strongly advised that this method only be used under explicit user
 * control. With enough errors, this method is likely to find a plausible
 * correction for any address (but for which no private key exists). This is
 * effectively equivalent to burning the funds.
 *
 * Only 2 substitution errors can be corrected (or a single swap) – deletions
 * and insertions (errors which shift many other characters and change the
 * length of the payload) can never be safely corrected and will produce an
 * error.
 *
 * Errors can be corrected in both the prefix and the payload, but attempting to
 * correct errors in the prefix prior to this method can improve results, e.g.
 * for `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x`, the string
 * `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can be corrected, while
 * `typo:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can not.
 *
 * @internalRemarks
 * Derived from: https://github.com/deadalnix/cashaddressed
 *
 * @param address the CashAddress on which to attempt error correction
 */
// eslint-disable-next-line complexity
export const attemptCashAddressFormatErrorCorrection = (address) => {
    const parts = address.toLowerCase().split(':');
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
        return CashAddressDecodingError.invalidFormat;
    }
    const [prefix, payload] = parts;
    if (!isBech32(payload)) {
        return CashAddressDecodingError.malformedPayload;
    }
    const decodedPayload = decodeBech32(payload);
    const polynomial = [...maskCashAddressPrefix(prefix), 0, ...decodedPayload];
    const originalChecksum = cashAddressPolynomialModulo(polynomial);
    if (originalChecksum === 0) {
        return {
            address: cashAddressPolynomialToCashAddress(polynomial),
            corrections: []
        };
    }
    const syndromes = {};
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let term = 0; term < polynomial.length; term++) {
        // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
        for (let errorVector = 1; errorVector < finiteFieldOrder; errorVector++) {
            // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
            polynomial[term] ^= errorVector;
            const correct = cashAddressPolynomialModulo(polynomial);
            if (correct === 0) {
                return {
                    address: cashAddressPolynomialToCashAddress(polynomial),
                    corrections: [term]
                };
            }
            // eslint-disable-next-line no-bitwise
            const s0 = (BigInt(correct) ^ BigInt(originalChecksum)).toString();
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            syndromes[s0] = term * finiteFieldOrder + errorVector;
            // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
            polynomial[term] ^= errorVector;
        }
    }
    // eslint-disable-next-line functional/no-loop-statement
    for (const [s0, pe] of Object.entries(syndromes)) {
        // eslint-disable-next-line no-bitwise
        const s1Location = (BigInt(s0) ^ BigInt(originalChecksum)).toString();
        const s1 = syndromes[s1Location];
        if (s1 !== undefined) {
            const correctionIndex1 = Math.trunc(pe / finiteFieldOrder);
            const correctionIndex2 = Math.trunc(s1 / finiteFieldOrder);
            // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
            polynomial[correctionIndex1] ^= pe % finiteFieldOrder;
            // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
            polynomial[correctionIndex2] ^= s1 % finiteFieldOrder;
            return {
                address: cashAddressPolynomialToCashAddress(polynomial),
                corrections: [correctionIndex1, correctionIndex2].sort((a, b) => a - b)
            };
        }
    }
    return CashAddressCorrectionError.tooManyErrors;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FzaC1hZGRyZXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9hZGRyZXNzL2Nhc2gtYWRkcmVzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRTdFLE1BQU0sQ0FBTixJQUFZLHdCQUlYO0FBSkQsV0FBWSx3QkFBd0I7SUFDbEMsbURBQXVCLENBQUE7SUFDdkIsK0NBQW1CLENBQUE7SUFDbkIsOENBQWtCLENBQUE7QUFDcEIsQ0FBQyxFQUpXLHdCQUF3QixLQUF4Qix3QkFBd0IsUUFJbkM7QUFFRCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRztJQUNsQyxDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0NBQ0UsQ0FBQztBQUVYLE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHO0lBQ2xDLEdBQUcsRUFBRSxDQUFDO0lBQ04sR0FBRyxFQUFFLENBQUM7SUFDTixHQUFHLEVBQUUsQ0FBQztJQUNOLEdBQUcsRUFBRSxDQUFDO0lBQ04sR0FBRyxFQUFFLENBQUM7SUFDTixHQUFHLEVBQUUsQ0FBQztJQUNOLEdBQUcsRUFBRSxDQUFDO0lBQ04sR0FBRyxFQUFFLENBQUM7Q0FDRSxDQUFDO0FBRVg7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsTUFBTSxDQUFOLElBQVksc0JBaUJYO0FBakJELFdBQVksc0JBQXNCO0lBQ2hDOzs7Ozs7T0FNRztJQUNILHFFQUFrQixDQUFBO0lBQ2xCOzs7Ozs7T0FNRztJQUNILG1FQUFpQixDQUFBO0FBQ25CLENBQUMsRUFq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