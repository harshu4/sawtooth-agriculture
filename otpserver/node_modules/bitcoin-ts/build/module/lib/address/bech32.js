/**
 * The list of 32 symbols used in Bech32 encoding.
 */
// cspell: disable-next-line
export const bech32CharacterSet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
// prettier-ignore
export const bech32CharacterSetIndex = { q: 0, p: 1, z: 2, r: 3, y: 4, '9': 5, x: 6, '8': 7, g: 8, f: 9, '2': 10, t: 11, v: 12, d: 13, w: 14, '0': 15, s: 16, '3': 17, j: 18, n: 19, '5': 20, '4': 21, k: 22, h: 23, c: 24, e: 25, '6': 26, m: 27, u: 28, a: 29, '7': 30, l: 31 }; // eslint-disable-line sort-keys
export var BitRegroupingError;
(function (BitRegroupingError) {
    BitRegroupingError["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
    BitRegroupingError["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
    BitRegroupingError["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError || (BitRegroupingError = {}));
/* eslint-disable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
// cSpell:ignore Pieter, Wuille
/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 *
 * @internalRemarks
 * Derived from: https://github.com/sipa/bech32
 * Copyright (c) 2017 Pieter Wuille, MIT License
 */
export const regroupBits = (bin, sourceWordLength, resultWordLength, padding = true) => {
    let accumulator = 0;
    let bits = 0;
    const result = [];
    const maxResultInt = (1 << resultWordLength) - 1;
    // eslint-disable-next-line functional/no-loop-statement, @typescript-eslint/prefer-for-of, no-plusplus
    for (let p = 0; p < bin.length; ++p) {
        const value = bin[p];
        if (value < 0 || value >> sourceWordLength !== 0) {
            return BitRegroupingError.integerOutOfRange;
        }
        accumulator = (accumulator << sourceWordLength) | value;
        bits += sourceWordLength;
        // eslint-disable-next-line functional/no-loop-statement
        while (bits >= resultWordLength) {
            bits -= resultWordLength;
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator >> bits) & maxResultInt);
        }
    }
    if (padding) {
        if (bits > 0) {
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator << (resultWordLength - bits)) & maxResultInt);
        }
    }
    else if (bits >= sourceWordLength) {
        return BitRegroupingError.hasDisallowedPadding;
    }
    else if (((accumulator << (resultWordLength - bits)) & maxResultInt) > 0) {
        return BitRegroupingError.requiresDisallowedPadding;
    }
    return result;
};
/* eslint-enable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`.
 *
 * @param base32IntegerArray the array of 5-bit integers to encode
 */
export const encodeBech32 = (base32IntegerArray) => {
    // eslint-disable-next-line functional/no-let
    let result = '';
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < base32IntegerArray.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement
        result += bech32CharacterSet[base32IntegerArray[i]];
    }
    return result;
};
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with `isBech32` before calling this method.
 *
 * @param validBech32 the bech32-encoded string to decode
 */
export const decodeBech32 = (validBech32) => {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < validBech32.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        result.push(bech32CharacterSetIndex[validBech32[i]]);
    }
    return result;
};
const nonBech32Characters = new RegExp(`[^${bech32CharacterSet}]`, 'u');
const base32WordLength = 5;
const base256WordLength = 8;
const zero = 0;
/**
 * Validate that a string is bech32 encoded (without a checksum). The string
 * must use only the bech32 character set, and it must be padded correctly, i.e.
 * it must encode a multiple of 8 bits.
 *
 * @param maybeBech32 a string to test for valid Bech32 encoding
 */
export const isBech32 = (maybeBech32) => {
    const expectedPadding = (maybeBech32.length * base32WordLength) % base256WordLength;
    const last5Bits = bech32CharacterSetIndex[maybeBech32[maybeBech32.length]];
    const onlyBech32Characters = !nonBech32Characters.test(maybeBech32);
    const noExcessivePadding = expectedPadding < base32WordLength;
    // eslint-disable-next-line no-bitwise
    const mask = (1 << expectedPadding) - 1;
    // eslint-disable-next-line no-bitwise
    const expectedPaddingIsZeroFilled = (Number(last5Bits) & mask) === zero;
    return (onlyBech32Characters && noExcessivePadding && expectedPaddingIsZeroFilled);
};
export var Bech32DecodingError;
(function (Bech32DecodingError) {
    Bech32DecodingError["notBech32Padded"] = "Bech32 decoding error: input is not in Bech32 padded format.";
})(Bech32DecodingError || (Bech32DecodingError = {}));
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * This method is the reverse of `binToBech32Padded`.
 *
 * @param bech32Padded the padded bech32-encoded string to decode
 */
export const bech32PaddedToBin = (bech32Padded) => {
    const result = isBech32(bech32Padded)
        ? regroupBits(decodeBech32(bech32Padded), base32WordLength, base256WordLength, false)
        : Bech32DecodingError.notBech32Padded;
    return typeof result === 'string' ? result : Uint8Array.from(result);
};
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * This method is the reverse of `bech32PaddedToBin`.
 *
 * @param bytes the Uint8Array to bech32 encode
 */
export const binToBech32Padded = (bytes) => encodeBech32(regroupBits(bytes, base256WordLength, base32WordLength));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVjaDMyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9hZGRyZXNzL2JlY2gzMi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRztBQUNILDRCQUE0QjtBQUM1QixNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxrQ0FBa0MsQ0FBQztBQUVyRTs7R0FFRztBQUNILGtCQUFrQjtBQUNsQixNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBVyxDQUFDLENB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