import { ErrorState, ExecutionStackState, StackState } from '../../state';
import { InstructionSetOperationMapping, Operation } from '../../virtual-machine';
import { AuthenticationErrorCommon } from './errors';
export declare const incrementOperationCount: <State extends {
    operationCount: number;
}>(operation: Operation<State>) => Operation<State>;
export declare const conditionallyEvaluate: <State extends ExecutionStackState>(operation: Operation<State>) => Operation<State>;
/**
 * Map a function over each operation in an `InstructionSet.operations` object,
 * assigning the result to the same `opcode` in the resulting object.
 * @param operations an operations map from an `InstructionSet`
 * @param combinator a function to apply to each operation
 */
export declare const mapOverOperations: <State>(operations: InstructionSetOperationMapping<State>, ...combinators: ((operation: Operation<State>) => Operation<State>)[]) => {
    [opcode: number]: Operation<State>;
};
/**
 * Pop one stack item off of `state.stack` and provide that item to `operation`.
 */
export declare const useOneStackItem: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, value: Uint8Array) => State) => State;
export declare const useTwoStackItems: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, valueTop: Uint8Array, valueTwo: Uint8Array) => State) => State;
export declare const useThreeStackItems: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, valueTop: Uint8Array, valueTwo: Uint8Array, valueThree: Uint8Array) => State) => State;
export declare const useFourStackItems: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, valueTop: Uint8Array, valueTwo: Uint8Array, valueThree: Uint8Array, valueFour: Uint8Array) => State) => State;
export declare const useSixStackItems: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, valueTop: Uint8Array, valueTwo: Uint8Array, valueThree: Uint8Array, valueFour: Uint8Array, valueFive: Uint8Array, valueSix: Uint8Array) => State) => State;
export declare const useOneScriptNumber: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, value: bigint) => State, requireMinimalEncoding: boolean, maximumScriptNumberByteLength?: number) => State;
export declare const useTwoScriptNumbers: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, firstValue: bigint, secondValue: bigint) => State, requireMinimalEncoding: boolean, maximumScriptNumberByteLength?: number) => State;
export declare const useThreeScriptNumbers: <State extends StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>(state: State, operation: (nextState: State, firstValue: bigint, secondValue: bigint, thirdValue: bigint) => State, requireMinimalEncoding: boolean, maximumScriptNumberByteLength?: number) => State;
/**
 * Return the provided state with the provided value pushed to its stack.
 * @param state the state to update and return
 * @param data the value to push to the stack
 */
export declare const pushToStack: <State extends StackState<Uint8Array>>(state: State, ...data: Uint8Array[]) => State;
export declare const combineOperations: <State>(firstOperation: Operation<State>, secondOperation: Operation<State>) => (state: State) => State;
//# sourceMappingURL=combinators.d.ts.map