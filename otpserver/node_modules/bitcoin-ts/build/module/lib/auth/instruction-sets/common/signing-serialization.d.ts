/**
 * A.K.A. `sighash` flags
 */
export declare enum SigningSerializationFlag {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    all_outputs = 1,
    /**
     * A.K.A `SIGHASH_NONE`
     */
    no_outputs = 2,
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    corresponding_output = 3,
    fork_id = 64,
    /**
     * A.K.A `ANYONE_CAN_PAY`
     */
    single_input = 128
}
export declare const isDefinedSigningSerializationType: (byte: number) => boolean;
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutpoints see `generateSigningSerializationBCH`
 */
export declare const hashPrevouts: (sha256: {
    hash: (input: Uint8Array) => Uint8Array;
}, signingSerializationType: Uint8Array, transactionOutpoints: Uint8Array) => Uint8Array;
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionSequenceNumbers see
 * `generateSigningSerializationBCH`
 */
export declare const hashSequence: (sha256: {
    hash: (input: Uint8Array) => Uint8Array;
}, signingSerializationType: Uint8Array, transactionSequenceNumbers: Uint8Array) => Uint8Array;
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutputs see `generateSigningSerializationBCH`
 * @param correspondingOutput see `generateSigningSerializationBCH`
 */
export declare const hashOutputs: (sha256: {
    hash: (input: Uint8Array) => Uint8Array;
}, signingSerializationType: Uint8Array, transactionOutputs: Uint8Array, correspondingOutput: Uint8Array | undefined) => Uint8Array;
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * @param version the version number of the transaction
 * @param transactionOutpoints the serialization of all input outpoints (A.K.A.
 * `hashPrevouts`) – used if `ANYONECANPAY` is not set
 * @param transactionSequenceNumbers the serialization of all input sequence
 * numbers. (A.K.A. `hashSequence`) – used if none of `ANYONECANPAY`, `SINGLE`,
 * or `NONE` are set.
 * @param outpointTransactionHash the big-endian (standard) transaction hash of
 * the outpoint being spent.
 * @param outpointIndex the index of the outpoint being spent in
 * `outpointTransactionHash`
 * @param coveredBytecode the script currently being executed, beginning at the
 * `lastCodeSeparator`.
 * @param outputValue the value of the outpoint in satoshis
 * @param sequenceNumber the sequence number of the input (A.K.A. `nSequence`)
 * @param correspondingOutput the serialization of the output at the same index
 * as this input (A.K.A. `hashOutputs` with `SIGHASH_SINGLE`) – only used if
 * `SINGLE` is set
 * @param transactionOutputs the serialization of output amounts and locking
 * bytecode values (A.K.A. `hashOutputs` with `SIGHASH_ALL`) – only used if
 * `ALL` is set
 * @param locktime the locktime of the transaction
 * @param signingSerializationType the signing serialization type of the
 * signature (A.K.A. `sighash` type)
 * @param forkId while a bitcoin-encoded signature only includes a single byte
 * to encode the signing serialization type, a 3-byte forkId can be appended to
 * provide replay-protection between different forks. (See Bitcoin Cash's Replay
 * Protected Sighash spec for details.)
 */
export declare const generateSigningSerializationBCH: (sha256: {
    hash: (input: Uint8Array) => Uint8Array;
}, version: number, transactionOutpoints: Uint8Array, transactionSequenceNumbers: Uint8Array, outpointTransactionHash: Uint8Array, outpointIndex: number, coveredBytecode: Uint8Array, outputValue: bigint, sequenceNumber: number, correspondingOutput: Uint8Array | undefined, transactionOutputs: Uint8Array, locktime: number, signingSerializationType: Uint8Array, forkId?: Uint8Array) => Uint8Array;
/**
 * @param signingSerializationType the 32-bit number indicating the signing
 * serialization algorithm to use
 */
export declare const isLegacySigningSerialization: (signingSerializationType: number) => boolean;
//# sourceMappingURL=signing-serialization.d.ts.map