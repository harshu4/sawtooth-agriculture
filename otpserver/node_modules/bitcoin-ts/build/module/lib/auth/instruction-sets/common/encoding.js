import { ConsensusBCH } from '../bch/bch';
import { isDefinedSigningSerializationType } from './signing-serialization';
export const isValidUncompressedPublicKeyEncoding = (publicKey) => publicKey.length === 65 /* uncompressedByteLength */ &&
    publicKey[0] === 4 /* uncompressedHeaderByte */;
export const isValidCompressedPublicKeyEncoding = (publicKey) => publicKey.length === 33 /* compressedByteLength */ &&
    (publicKey[0] === 2 /* compressedHeaderByteEven */ ||
        publicKey[0] === 3 /* compressedHeaderByteOdd */);
export const isValidPublicKeyEncoding = (publicKey) => isValidCompressedPublicKeyEncoding(publicKey) ||
    isValidUncompressedPublicKeyEncoding(publicKey);
const isNegative = (value) => 
// eslint-disable-next-line no-bitwise
(value & 128 /* negative */) !== 0;
const hasUnnecessaryPadding = (length, firstByte, secondByte) => length > 1 && firstByte === 0 && !isNegative(secondByte);
const isValidInteger = (signature, tagIndex, length, valueIndex) => signature[tagIndex] === 2 /* integerTagType */ &&
    length !== 0 &&
    !isNegative(signature[valueIndex]) &&
    !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
/**
 * Validate a DER-encoded signature.
 *
 * @remarks
 * This function is consensus-critical since BIP66, but differs from the BIP66
 * specification in that it does not validate the existence of a signing
 * serialization type byte at the end of the signature (to support
 * OP_CHECKDATASIG). To validate a bitcoin-encoded signature (including null
 * signatures), use `isValidSignatureEncodingBCH`.
 *
 * @internalRemarks
 * From the Bitcoin ABC C++ implementation:
 *
 * Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
 * total-length: 1-byte length descriptor of everything that follows,
 * excluding the sighash byte.
 * R-length: 1-byte length descriptor of the R value that follows.
 * R: arbitrary-length big-endian encoded R value. It must use the
 * shortest possible encoding for a positive integers (which means no null
 * bytes at the start, except a single one when the next byte has its highest
 * bit set).
 * S-length: 1-byte length descriptor of the S value that follows.
 * S: arbitrary-length big-endian encoded S value. The same rules apply.
 */
// eslint-disable-next-line complexity
export const isValidSignatureEncodingDER = (signature) => {
    const correctLengthRange = signature.length > 8 /* minimumLength */ &&
        signature.length < 72 /* maximumLength */;
    const correctSequenceTagType = signature[0 /* sequenceTagIndex */] === 48 /* sequenceTagType */;
    const correctSequenceLength = signature[1 /* sequenceLengthIndex */] ===
        signature.length - 2 /* sequenceMetadataBytes */;
    const rLength = signature[3 /* rLengthIndex */];
    if (rLength === undefined) {
        return false;
    }
    const consistentRLength = rLength <= signature.length - 7 /* minimumNonRValueBytes */;
    const rIsValid = isValidInteger(signature, 2 /* rTagIndex */, rLength, 4 /* rValueIndex */);
    const sTagIndex = 4 /* rValueIndex */ + rLength; // eslint-disable-line @typescript-eslint/restrict-plus-operands
    const sLengthIndex = sTagIndex + 1;
    const sLength = signature[sLengthIndex];
    if (sLength === undefined) {
        return false;
    }
    const sValueIndex = sLengthIndex + 1;
    const consistentSLength = sValueIndex + sLength === signature.length;
    const sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
    return (correctLengthRange &&
        correctSequenceTagType &&
        correctSequenceLength &&
        consistentRLength &&
        rIsValid &&
        consistentSLength &&
        sIsValid);
};
/**
 * Validate the encoding of a transaction signature, including a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param transactionSignature the full transaction signature
 */
export const isValidSignatureEncodingBCHTransaction = (transactionSignature) => transactionSignature.length === 0 ||
    transactionSignature.length === ConsensusBCH.schnorrSignatureLength + 1 ||
    (isDefinedSigningSerializationType(transactionSignature[transactionSignature.length - 1]) &&
        isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1)));
/**
 * Split a bitcoin-encoded signature into a signature and signing serialization
 * type.
 *
 * While a bitcoin-encoded signature only includes a single byte to encode the
 * signing serialization type, a 3-byte forkId can be appended to the signing
 * serialization to provide replay-protection between different forks. (See
 * Bitcoin Cash's Replay Protected Sighash spec for details.)
 *
 * @param signature a signature which passes `isValidSignatureEncoding`
 */
export const decodeBitcoinSignature = (encodedSignature) => ({
    signature: encodedSignature.slice(0, encodedSignature.length - 1),
    signingSerializationType: new Uint8Array([
        encodedSignature[encodedSignature.length - 1]
    ])
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2RpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvaW5zdHJ1Y3Rpb24tc2V0cy9jb21tb24vZW5jb2RpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLFlBQVksQ0FBQztBQUUxQyxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQVU1RSxNQUFNLENBQUMsTUFBTSxvQ0FBb0MsR0FBRyxDQUFDLFNBQXFCLEVBQUUsRUFBRSxDQUM1RSxTQUFTLENBQUMsTUFBTSxvQ0FBcUM7SUFDckQsU0FBUyxDQUFDLENBQUMsQ0FBQyxtQ0FBcUMsQ0FBQztBQUVwRCxNQUFNLENBQUMsTUFBTSxrQ0FBa0MsR0FBRyxDQUFDLFNBQXFCLEVBQUUsRUFBRSxDQUMxRSxTQUFTLENBQUMsTUFBTSxrQ0FBbUM7SUFDbkQsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLHFDQUF1QztRQUNsRCxTQUFTLENBQUMsQ0FBQyxDQUFDLG9DQUFzQyxDQUFDLENBQUM7QUFFeEQsTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxTQUFxQixFQUFFLEVBQUUsQ0FDaEUsa0NBQWtDLENBQUMsU0FBUyxDQUFDO0lBQzdDLG9DQUFvQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBcUNsRCxNQUFNLFVBQVUsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO0FBQ25DLHNDQUFzQztBQUN0QyxDQUFDLEtBQUsscUJBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFaEMsTUFBTSxxQkFBcUIsR0FBRyxDQUM1QixNQUFjLEVBQ2QsU0FBaUIsRUFDakIsVUFBa0IsRUFDbEIsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUU5RCxNQUFNLGNBQWMsR0FBRyxD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