import { binToHex, flattenBinArray } from '../../utils/utils';
import { OpcodesBCH } from './bch/bch';
import { OpcodesBTC } from './btc/btc';
export const authenticationInstructionIsMalformed = (instruction) => instruction.malformed;
export const authenticationInstructionsAreMalformed = (instructions) => instructions.length > 0 &&
    authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
export const authenticationInstructionsAreNotMalformed = (instructions) => !authenticationInstructionsAreMalformed(instructions);
var CommonPushOpcodes;
(function (CommonPushOpcodes) {
    CommonPushOpcodes[CommonPushOpcodes["OP_0"] = 0] = "OP_0";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
})(CommonPushOpcodes || (CommonPushOpcodes = {}));
var Bytes;
(function (Bytes) {
    Bytes[Bytes["Uint8"] = 1] = "Uint8";
    Bytes[Bytes["Uint16"] = 2] = "Uint16";
    Bytes[Bytes["Uint32"] = 4] = "Uint32";
})(Bytes || (Bytes = {}));
/**
 * Note: this implementation assumes `script` is defined and long enough to read
 * the specified number of bytes. If necessary, validation should be done before
 * calling this method.
 *
 * @param script the Uint8Array from which to read
 * @param index the index from which to begin reading
 * @param length the number of bytes to read
 */
export const readLittleEndianNumber = (script, index, length) => {
    const view = new DataView(script.buffer, index, length);
    const readAsLittleEndian = true;
    return length === Bytes.Uint8
        ? view.getUint8(0)
        : length === Bytes.Uint16
            ? view.getUint16(0, readAsLittleEndian)
            : view.getUint32(0, readAsLittleEndian);
};
/**
 * Note: this implementation assumes `script` is defined and long enough to
 * write the specified number of bytes. It also assumes the provided `number` is
 * representable in `length` bytes.
 *
 * If necessary, validation should be done before calling this method.
 *
 * @param script the Uint8Array to which the number should be written
 * @param index the index at which to begin reading
 * @param length the number of bytes to use
 * @param value the number to write at `script[index]`
 */
export const writeLittleEndianNumber = (script, index, length, value) => {
    const view = new DataView(script.buffer, index, length);
    const writeAsLittleEndian = true;
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions, functional/no-expression-statement
    length === Bytes.Uint8
        ? view.setUint8(0, value)
        : length === Bytes.Uint16
            ? view.setUint16(0, value, writeAsLittleEndian)
            : view.setUint32(0, value, writeAsLittleEndian);
    return script;
};
export const numberToLittleEndianBin = (value, length) => {
    const array = new Uint8Array(length);
    return writeLittleEndianNumber(array, 0, length, value);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode an opcode between 0x00 and 0x4e
 */
export const lengthBytesForPushOpcode = (opcode) => opcode < CommonPushOpcodes.OP_PUSHDATA_1
    ? 0
    : opcode === CommonPushOpcodes.OP_PUSHDATA_1
        ? Bytes.Uint8
        : opcode === CommonPushOpcodes.OP_PUSHDATA_2
            ? Bytes.Uint16
            : Bytes.Uint32;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script the script from which to read the next instruction
 * @param index the offset from which to begin reading
 */
// eslint-disable-next-line complexity
export const readAuthenticationInstruction = (script, index) => {
    const opcode = script[index];
    if (opcode > CommonPushOpcodes.OP_PUSHDATA_4) {
        return {
            instruction: {
                opcode: opcode
            },
            nextIndex: index + 1
        };
    }
    const lengthBytes = lengthBytesForPushOpcode(opcode);
    const pushBytes = lengthBytes === 0;
    if (!pushBytes && index + lengthBytes >= script.length) {
        const sliceStart = index + 1;
        const sliceEnd = sliceStart + lengthBytes;
        return {
            instruction: {
                expectedLengthBytes: lengthBytes,
                length: script.slice(sliceStart, sliceEnd),
                malformed: true,
                opcode: opcode
            },
            nextIndex: sliceEnd
        };
    }
    const dataBytes = pushBytes
        ? opcode
        : readLittleEndianNumber(script, index + 1, lengthBytes);
    const dataStart = index + 1 + lengthBytes;
    const dataEnd = dataStart + dataBytes;
    return {
        instruction: {
            data: script.slice(dataStart, dataEnd),
            ...(dataEnd > script.length
                ? {
                    expectedDataBytes: dataEnd - dataStart,
                    malformed: true
                }
                : undefined),
            opcode: opcode
        },
        nextIndex: dataEnd
    };
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script the serialized script to parse
 */
export const parseBytecode = (script) => {
    const instructions = [];
    // eslint-disable-next-line functional/no-let
    let i = 0;
    // eslint-disable-next-line functional/no-loop-statement
    while (i < script.length) {
        const { instruction, nextIndex } = readAuthenticationInstruction(script, i);
        // eslint-disable-next-line functional/no-expression-statement
        i = nextIndex;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        instructions.push(instruction);
    }
    return instructions;
};
const isPush = (instruction) => instruction.data !== undefined;
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */
const isMultiWordPush = (opcode) => opcode !== CommonPushOpcodes.OP_0;
const formatAsmPushHex = (data) => data.length > 0 ? `0x${binToHex(data)}` : '';
const formatMissingBytesAsm = (missing) => `[missing ${missing} byte${missing === 1 ? '' : 's'}]`;
const hasMalformedLength = (instruction) => instruction
    .length !== undefined;
const isPushData = (pushOpcode) => lengthBytesForPushOpcode(pushOpcode) > 0;
export const disassembleParsedAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode]} ${hasMalformedLength(instruction)
    ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}`
    : `${isPushData(instruction.opcode)
        ? `${instruction.expectedDataBytes} `
        : ''}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
export const disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode]}${isPush(instruction) &&
    isMultiWordPush(instruction.opcode)
    ? ` ${isPushData(instruction.opcode)
        ? `${instruction.data.length} `
        : ''}${formatAsmPushHex(instruction.data)}`
    : ''}`;
export const disassembleParsedAuthenticationInstruction = (opcodes, instruction) => authenticationInstructionIsMalformed(instruction)
    ? disassembleParsedAuthenticationInstructionMalformed(opcodes, instruction)
    : disassembleAuthenticationInstruction(opcodes, instruction);
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script the array of instructions to disassemble
 */
export const disassembleParsedAuthenticationInstructions = (opcodes, instructions) => instructions
    .map(instruction => disassembleParsedAuthenticationInstruction(opcodes, instruction))
    .join(' ');
/**
 * Disassemble authentication bytecode into a lossless ASM representation.
 *
 * TODO: a similar method which re-formats ASM strings, converting HexLiterals to Script Numbers or UTF8Literals.
 *
 * @param opcodes the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode the authentication bytecode to disassemble
 */
export const disassembleBytecode = (opcodes, bytecode) => disassembleParsedAuthenticationInstructions(opcodes, parseBytecode(bytecode));
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */
export const disassembleBytecodeBCH = (bytecode) => disassembleParsedAuthenticationInstructions(OpcodesBCH, parseBytecode(bytecode));
// TODO: assembleBytecodeBCH â€“ instantiate synchronous compiler, throw any errors
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */
export const disassembleBytecodeBTC = (bytecode) => disassembleParsedAuthenticationInstructions(OpcodesBTC, parseBytecode(bytecode));
// TODO: assembleBytecodeBTC
const getLengthBytes = (instruction) => numberToLittleEndianBin(instruction.data.length, lengthBytesForPushOpcode(instruction.opcode));
export const serializeAuthenticationInstruction = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...(isPush(instruction)
        ? [
            ...(isPushData(instruction.opcode)
                ? getLengthBytes(instruction)
                : []),
            ...instruction.data
        ]
        : [])
]);
export const serializeParsedAuthenticationInstructionMalformed = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...(hasMalformedLength(instruction)
        ? instruction.length
        : isPushData(instruction.opcode)
            ? numberToLittleEndianBin(instruction.expectedDataBytes, lengthBytesForPushOpcode(instruction.opcode))
            : []),
    ...(hasMalformedLength(instruction) ? [] : instruction.data)
]);
export const serializeParsedAuthenticationInstruction = (instruction) => authenticationInstructionIsMalformed(instruction)
    ? serializeParsedAuthenticationInstructionMalformed(instruction)
    : serializeAuthenticationInstruction(instruction);
export const serializeAuthenticationInstructions = (instructions) => flattenBinArray(instructions.map(serializeAuthenticationInstruction));
export const serializeParsedAuthenticationInstructions = (instructions) => flattenBinArray(instructions.map(serializeParsedAuthenticationInstruction));
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes An opcode enum, e.g. `OpcodesBCH`
 */
export const generateBytecodeMap = (opcodes) => Object.entries(opcodes)
    .filter((entry) => typeof entry[1] === 'number')
    .reduce((identifiers, pair) => ({
    ...identifiers,
    [pair[0]]: Uint8Array.of(pair[1])
}), {});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdHJ1Y3Rpb24tc2V0cy11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvYXV0aC9pbnN0cnVjdGlvbi1zZXRzL2luc3RydWN0aW9uLXNldHMtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUU5RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFVdkMsTUFBTSxDQUFDLE1BQU0sb0NBQW9DLEdBQUcsQ0FDbEQsV0FBcUQsRUFDYSxFQUFFLENBQ25FLFdBQWlFLENBQUMsU0FBUyxDQUFDO0FBRS9FLE1BQU0sQ0FBQyxNQUFNLHNDQUFzQyxHQUFHLENBQ3BELFlBQXVELEVBQ2MsRUFBRSxDQUN2RSxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUM7SUFDdkIsb0NBQW9DLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU5RSxNQUFNLENBQUMsTUFBTSx5Q0FBeUMsR0FBRyxDQUN2RCxZQUF1RCxFQUNELEVBQUUsQ0FDeEQsQ0FBQyxzQ0FBc0MsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUV4RCxJQUFLLGlCQUtKO0FBTEQsV0FBSyxpQkFBaUI7SUFDcEIseURBQVcsQ0FBQTtJQUNYLDRFQUFvQixDQUFBO0lBQ3BCLDRFQUFvQixDQUFBO0lBQ3BCLDRFQUFvQixDQUFBO0FBQ3RCLENBQUMsRUFMSSxpQkFBaUIsS0FBakIsaUJBQWlCLFFBS3JCO0FBRUQsSUFBSyxLQUlKO0FBSkQsV0FBSyxLQUFLO0lBQ1IsbUNBQVMsQ0FBQTtJQUNULHFDQUFVLENBQUE7SUFDVixxQ0FBVSxDQUFBO0FBQ1osQ0FBQyxFQUpJLEtBQUssS0FBTCxLQUFLLFFBSVQ7QUFFRDs7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