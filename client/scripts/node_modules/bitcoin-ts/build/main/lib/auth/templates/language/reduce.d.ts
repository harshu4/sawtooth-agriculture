import { AuthenticationInstruction } from '../../instruction-sets/instruction-sets-types';
import { MinimumProgramState, StackState } from '../../state';
import { AuthenticationVirtualMachine } from '../../virtual-machine';
import { ErrorInformation } from './errors';
import { Range, ResolvedScript } from './resolve';
export interface ScriptReductionTraceNode {
    bytecode: Uint8Array;
    errors?: ErrorInformation[] | undefined;
    range: Range;
}
interface ScriptReductionTraceErrorNode extends ScriptReductionTraceNode {
    errors?: ErrorInformation[];
}
export interface ScriptReductionTraceContainerNode<ProgramState> extends ScriptReductionTraceNode {
    source: ScriptReductionTraceChildNode<ProgramState>[];
}
export declare type ScriptReductionTraceChildNode<ProgramState> = ScriptReductionTraceNode | ScriptReductionTraceContainerNode<ProgramState> | ScriptReductionTraceErrorNode | ScriptReductionTraceEvaluationNode<ProgramState>;
export interface TraceSample<ProgramState> {
    range: Range;
    state: ProgramState;
}
export interface ScriptReductionTraceEvaluationNode<ProgramState> extends ScriptReductionTraceContainerNode<ProgramState> {
    samples: TraceSample<ProgramState>[];
}
/**
 * Evaluate an array of `InstructionAggregation`s with the provided
 * `AuthenticationVirtualMachine`, matching the results back to their source
 * ranges.
 */
export declare const evaluateInstructionAggregations: <Opcodes, ProgramState extends MinimumProgramState<Opcodes> & {
    error?: string | undefined;
}>(aggregations: InstructionAggregation<Opcodes>[], vm: AuthenticationVirtualMachine<any, ProgramState>, getState: (instructions: AuthenticationInstruction<Opcodes>[]) => ProgramState) => InstructionAggregationEvaluationResult<ProgramState>;
/**
 * Incrementally evaluate an array of `ScriptReductionTraceNode`s, returning a
 * trace of the evaluation and the resulting top stack item (`evaluationResult`)
 * if successful.
 *
 * @param nodes an array of reduced nodes
 * @param vm the `AuthenticationVirtualMachine` to use in the evaluation
 * @param getState a method which should generate a new ProgramState given an
 * array of `instructions`
 */
export declare const sampledEvaluateReductionTraceNodes: <Opcodes, ProgramState extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & {
    error?: string | undefined;
}>(nodes: ScriptReductionTraceNode[], vm: AuthenticationVirtualMachine<any, ProgramState>, getState: (instructions: AuthenticationInstruction<Opcodes>[]) => ProgramState) => SampledEvaluationResult<ProgramState>;
/**
 * This method will throw an error if provided a `compiledScript` with
 * compilation errors. To check for compilation errors, use `getCompileErrors`.
 * @param compiledScript the `CompiledScript` to reduce
 * @param vm the `AuthenticationVirtualMachine` to use for evaluations
 * @param createState a method which returns the base `ProgramState` used when initializing evaluations
 */
export declare const reduceScript: <ProgramState extends StackState<Uint8Array> & MinimumProgramState<Opcodes>, Opcodes>(compiledScript: ResolvedScript, vm?: AuthenticationVirtualMachine<any, ProgramState> | undefined, createState?: ((instructions: AuthenticationInstruction<Opcodes>[]) => ProgramState) | undefined) => ScriptReductionTraceContainerNode<ProgramState>;
export interface InstructionAggregation<Opcodes> {
    instructions: AuthenticationInstruction<Opcodes>[];
    lastIp: number;
    range: Range;
}
export interface InstructionAggregationSuccess<Opcodes> {
    aggregations: InstructionAggregation<Opcodes>[];
    success: true;
}
export interface InstructionAggregationError<Opcodes> {
    aggregations: InstructionAggregation<Opcodes>[];
    remainingBytecode: Uint8Array;
    remainingRange: Range;
    success: false;
}
export declare type InstructionAggregationResult<Opcodes> = InstructionAggregationSuccess<Opcodes> | InstructionAggregationError<Opcodes>;
export interface EvaluationSample<ProgramState> {
    range: Range;
    state: ProgramState | undefined;
}
export interface EvaluationSampleValid<ProgramState> {
    range: Range;
    state: ProgramState;
}
export interface InstructionAggregationEvaluationError<ProgramState> {
    errors: ErrorInformation[];
    samples: EvaluationSample<ProgramState>[];
    success: false;
}
export interface InstructionAggregationEvaluationSuccess<ProgramState> {
    samples: EvaluationSampleValid<ProgramState>[];
    success: true;
}
declare type InstructionAggregationEvaluationResult<ProgramState> = InstructionAggregationEvaluationError<ProgramState> | InstructionAggregationEvaluationSuccess<ProgramState>;
export interface SampledEvaluationSuccess<ProgramState> {
    bytecode: Uint8Array;
    samples: EvaluationSampleValid<ProgramState>[];
    success: true;
}
export interface SampledEvaluationError<ProgramState> {
    bytecode: Uint8Array;
    errors: ErrorInformation[];
    samples: EvaluationSample<ProgramState>[];
    success: false;
}
export declare type SampledEvaluationResult<ProgramState> = SampledEvaluationSuccess<ProgramState> | SampledEvaluationError<ProgramState>;
export interface FlattenedTraceSample<ProgramState> extends TraceSample<ProgramState> {
    /**
     * The nesting-depth of this sample. (E.g. the first level of evaluation has a
     * depth of `1`, an evaluation inside of it will produce samples with a depth
     * of `2`, etc.)
     */
    depth: number;
}
export {};
//# sourceMappingURL=reduce.d.ts.map