"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils/utils");
const bch_1 = require("./bch/bch");
const btc_1 = require("./btc/btc");
exports.authenticationInstructionIsMalformed = (instruction) => instruction.malformed;
exports.authenticationInstructionsAreMalformed = (instructions) => instructions.length > 0 &&
    exports.authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
exports.authenticationInstructionsAreNotMalformed = (instructions) => !exports.authenticationInstructionsAreMalformed(instructions);
var CommonPushOpcodes;
(function (CommonPushOpcodes) {
    CommonPushOpcodes[CommonPushOpcodes["OP_0"] = 0] = "OP_0";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
})(CommonPushOpcodes || (CommonPushOpcodes = {}));
var Bytes;
(function (Bytes) {
    Bytes[Bytes["Uint8"] = 1] = "Uint8";
    Bytes[Bytes["Uint16"] = 2] = "Uint16";
    Bytes[Bytes["Uint32"] = 4] = "Uint32";
})(Bytes || (Bytes = {}));
/**
 * Note: this implementation assumes `script` is defined and long enough to read
 * the specified number of bytes. If necessary, validation should be done before
 * calling this method.
 *
 * @param script the Uint8Array from which to read
 * @param index the index from which to begin reading
 * @param length the number of bytes to read
 */
exports.readLittleEndianNumber = (script, index, length) => {
    const view = new DataView(script.buffer, index, length);
    const readAsLittleEndian = true;
    return length === Bytes.Uint8
        ? view.getUint8(0)
        : length === Bytes.Uint16
            ? view.getUint16(0, readAsLittleEndian)
            : view.getUint32(0, readAsLittleEndian);
};
/**
 * Note: this implementation assumes `script` is defined and long enough to
 * write the specified number of bytes. It also assumes the provided `number` is
 * representable in `length` bytes.
 *
 * If necessary, validation should be done before calling this method.
 *
 * @param script the Uint8Array to which the number should be written
 * @param index the index at which to begin reading
 * @param length the number of bytes to use
 * @param value the number to write at `script[index]`
 */
exports.writeLittleEndianNumber = (script, index, length, value) => {
    const view = new DataView(script.buffer, index, length);
    const writeAsLittleEndian = true;
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions, functional/no-expression-statement
    length === Bytes.Uint8
        ? view.setUint8(0, value)
        : length === Bytes.Uint16
            ? view.setUint16(0, value, writeAsLittleEndian)
            : view.setUint32(0, value, writeAsLittleEndian);
    return script;
};
exports.numberToLittleEndianBin = (value, length) => {
    const array = new Uint8Array(length);
    return exports.writeLittleEndianNumber(array, 0, length, value);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode an opcode between 0x00 and 0x4e
 */
exports.lengthBytesForPushOpcode = (opcode) => opcode < CommonPushOpcodes.OP_PUSHDATA_1
    ? 0
    : opcode === CommonPushOpcodes.OP_PUSHDATA_1
        ? Bytes.Uint8
        : opcode === CommonPushOpcodes.OP_PUSHDATA_2
            ? Bytes.Uint16
            : Bytes.Uint32;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script the script from which to read the next instruction
 * @param index the offset from which to begin reading
 */
// eslint-disable-next-line complexity
exports.readAuthenticationInstruction = (script, index) => {
    const opcode = script[index];
    if (opcode > CommonPushOpcodes.OP_PUSHDATA_4) {
        return {
            instruction: {
                opcode: opcode
            },
            nextIndex: index + 1
        };
    }
    const lengthBytes = exports.lengthBytesForPushOpcode(opcode);
    const pushBytes = lengthBytes === 0;
    if (!pushBytes && index + lengthBytes >= script.length) {
        const sliceStart = index + 1;
        const sliceEnd = sliceStart + lengthBytes;
        return {
            instruction: {
                expectedLengthBytes: lengthBytes,
                length: script.slice(sliceStart, sliceEnd),
                malformed: true,
                opcode: opcode
            },
            nextIndex: sliceEnd
        };
    }
    const dataBytes = pushBytes
        ? opcode
        : exports.readLittleEndianNumber(script, index + 1, lengthBytes);
    const dataStart = index + 1 + lengthBytes;
    const dataEnd = dataStart + dataBytes;
    return {
        instruction: Object.assign(Object.assign({ data: script.slice(dataStart, dataEnd) }, (dataEnd > script.length
            ? {
                expectedDataBytes: dataEnd - dataStart,
                malformed: true
            }
            : undefined)), { opcode: opcode }),
        nextIndex: dataEnd
    };
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script the serialized script to parse
 */
exports.parseBytecode = (script) => {
    const instructions = [];
    // eslint-disable-next-line functional/no-let
    let i = 0;
    // eslint-disable-next-line functional/no-loop-statement
    while (i < script.length) {
        const { instruction, nextIndex } = exports.readAuthenticationInstruction(script, i);
        // eslint-disable-next-line functional/no-expression-statement
        i = nextIndex;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        instructions.push(instruction);
    }
    return instructions;
};
const isPush = (instruction) => instruction.data !== undefined;
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */
const isMultiWordPush = (opcode) => opcode !== CommonPushOpcodes.OP_0;
const formatAsmPushHex = (data) => data.length > 0 ? `0x${utils_1.binToHex(data)}` : '';
const formatMissingBytesAsm = (missing) => `[missing ${missing} byte${missing === 1 ? '' : 's'}]`;
const hasMalformedLength = (instruction) => instruction
    .length !== undefined;
const isPushData = (pushOpcode) => exports.lengthBytesForPushOpcode(pushOpcode) > 0;
exports.disassembleParsedAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode]} ${hasMalformedLength(instruction)
    ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}`
    : `${isPushData(instruction.opcode)
        ? `${instruction.expectedDataBytes} `
        : ''}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
exports.disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode]}${isPush(instruction) &&
    isMultiWordPush(instruction.opcode)
    ? ` ${isPushData(instruction.opcode)
        ? `${instruction.data.length} `
        : ''}${formatAsmPushHex(instruction.data)}`
    : ''}`;
exports.disassembleParsedAuthenticationInstruction = (opcodes, instruction) => exports.authenticationInstructionIsMalformed(instruction)
    ? exports.disassembleParsedAuthenticationInstructionMalformed(opcodes, instruction)
    : exports.disassembleAuthenticationInstruction(opcodes, instruction);
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script the array of instructions to disassemble
 */
exports.disassembleParsedAuthenticationInstructions = (opcodes, instructions) => instructions
    .map(instruction => exports.disassembleParsedAuthenticationInstruction(opcodes, instruction))
    .join(' ');
/**
 * Disassemble authentication bytecode into a lossless ASM representation.
 *
 * TODO: a similar method which re-formats ASM strings, converting HexLiterals to Script Numbers or UTF8Literals.
 *
 * @param opcodes the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode the authentication bytecode to disassemble
 */
exports.disassembleBytecode = (opcodes, bytecode) => exports.disassembleParsedAuthenticationInstructions(opcodes, exports.parseBytecode(bytecode));
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */
exports.disassembleBytecodeBCH = (bytecode) => exports.disassembleParsedAuthenticationInstructions(bch_1.OpcodesBCH, exports.parseBytecode(bytecode));
// TODO: assembleBytecodeBCH â€“ instantiate synchronous compiler, throw any errors
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */
exports.disassembleBytecodeBTC = (bytecode) => exports.disassembleParsedAuthenticationInstructions(btc_1.OpcodesBTC, exports.parseBytecode(bytecode));
// TODO: assembleBytecodeBTC
const getLengthBytes = (instruction) => exports.numberToLittleEndianBin(instruction.data.length, exports.lengthBytesForPushOpcode(instruction.opcode));
exports.serializeAuthenticationInstruction = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...(isPush(instruction)
        ? [
            ...(isPushData(instruction.opcode)
                ? getLengthBytes(instruction)
                : []),
            ...instruction.data
        ]
        : [])
]);
exports.serializeParsedAuthenticationInstructionMalformed = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...(hasMalformedLength(instruction)
        ? instruction.length
        : isPushData(instruction.opcode)
            ? exports.numberToLittleEndianBin(instruction.expectedDataBytes, exports.lengthBytesForPushOpcode(instruction.opcode))
            : []),
    ...(hasMalformedLength(instruction) ? [] : instruction.data)
]);
exports.serializeParsedAuthenticationInstruction = (instruction) => exports.authenticationInstructionIsMalformed(instruction)
    ? exports.serializeParsedAuthenticationInstructionMalformed(instruction)
    : exports.serializeAuthenticationInstruction(instruction);
exports.serializeAuthenticationInstructions = (instructions) => utils_1.flattenBinArray(instructions.map(exports.serializeAuthenticationInstruction));
exports.serializeParsedAuthenticationInstructions = (instructions) => utils_1.flattenBinArray(instructions.map(exports.serializeParsedAuthenticationInstruction));
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes An opcode enum, e.g. `OpcodesBCH`
 */
exports.generateBytecodeMap = (opcodes) => Object.entries(opcodes)
    .filter((entry) => typeof entry[1] === 'number')
    .reduce((identifiers, pair) => (Object.assign(Object.assign({}, identifiers), { [pair[0]]: Uint8Array.of(pair[1]) })), {});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdHJ1Y3Rpb24tc2V0cy11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvYXV0aC9pbnN0cnVjdGlvbi1zZXRzL2luc3RydWN0aW9uLXNldHMtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSw2Q0FBOEQ7QUFFOUQsbUNBQXVDO0FBQ3ZDLG1DQUF1QztBQVUxQixRQUFBLG9DQUFvQyxHQUFHLENBQ2xELFdBQXFELEVBQ2EsRUFBRSxDQUNuRSxXQUFpRSxDQUFDLFNBQVMsQ0FBQztBQUVsRSxRQUFBLHNDQUFzQyxHQUFHLENBQ3BELFlBQXVELEVBQ2MsRUFBRSxDQUN2RSxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUM7SUFDdkIsNENBQW9DLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUVqRSxRQUFBLHlDQUF5QyxHQUFHLENBQ3ZELFlBQXVELEVBQ0QsRUFBRSxDQUN4RCxDQUFDLDhDQUFzQyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBRXhELElBQUssaUJBS0o7QUFMRCxXQUFLLGlCQUFpQjtJQUNwQix5REFBVyxDQUFBO0lBQ1gsNEVBQW9CLENBQUE7SUFDcEIsNEVBQW9CLENBQUE7SUFDcEIsNEVBQW9CLENBQUE7QUFDdEIsQ0FBQyxFQUxJLGlCQUFpQixLQUFqQixpQkFBaUIsUUFLckI7QUFFRCxJQUFLLEtBSUo7QUFKRCxXQUFLLEtBQUs7SUFDUixtQ0FBUyxDQUFBO0lBQ1QscUNBQVUsQ0FBQTtJQUNWLHFDQUFVLENBQUE7QUFDWixDQUFDLEVBSkksS0FBSyxLQUFMLEtBQUssUUFJVDtBQUVEOzs7Ozs7OztHQVFHO0FBQ1UsUUFBQSxzQkFBc0IsR0FBRyxDQUNwQyxNQUFrQixFQUNsQixLQUFhLEVBQ2IsTUFBYSxFQUNiLEVBQUU7SUFDRixNQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFB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