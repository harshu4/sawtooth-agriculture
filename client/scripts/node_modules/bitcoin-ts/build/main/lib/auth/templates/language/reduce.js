"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../../utils/utils");
const opcodes_1 = require("../../instruction-sets/common/opcodes");
const instruction_sets_1 = require("../../instruction-sets/instruction-sets");
const instruction_sets_utils_1 = require("../../instruction-sets/instruction-sets-utils");
const pluckStartPosition = (range) => ({
    startColumn: range.startColumn,
    startLineNumber: range.startLineNumber
});
const pluckEndPosition = (range) => ({
    endColumn: range.endColumn,
    endLineNumber: range.endLineNumber
});
const mergeRanges = (ranges) => {
    const unsortedMerged = ranges.reduce(
    // eslint-disable-next-line complexity
    (merged, range) => (Object.assign(Object.assign({}, (range.startLineNumber < merged.startLineNumber
        ? pluckStartPosition(range)
        : range.startLineNumber === merged.startLineNumber &&
            range.startColumn < merged.startColumn
            ? pluckStartPosition(range)
            : pluckStartPosition(merged))), (range.endLineNumber > merged.endLineNumber
        ? pluckEndPosition(range)
        : range.endLineNumber === merged.endLineNumber &&
            range.endColumn > merged.endColumn
            ? pluckEndPosition(range)
            : pluckEndPosition(merged)))), ranges[0]);
    return Object.assign(Object.assign({}, pluckStartPosition(unsortedMerged)), pluckEndPosition(unsortedMerged));
};
const emptyReductionTraceNode = (range) => ({
    bytecode: Uint8Array.of(),
    range
});
/**
 * Aggregate instructions to build groups of non-malformed instructions.
 *
 * --- TODO: delete old stuff below? â€“â€“-
 *
 * So users can write constructions like `OP_PUSHBYTES_2 0x0102` which will
 * evaluate successfully, but instructions which must read over a new-line to
 * make sense (e.g. `OP_PUSHBYTES_2\n0x0102`) should error. This allows for a
 * nice omniscient-debugging experience.
 *
 * **This makes new lines important in evaluations.** However, things
 * can only "break" when new lines are inserted, not when they are removed (e.g.
 * if a script is "minified" to a single line for deployment.)
 *
 * **Implementation note**
 * This method aggregates arrays of instructions by line... a little like
 * Automatic Semicolon Insertion in ECMAScript. ðŸ‘€ In fact, that's a good
 * sign that we're missing a useful language construct here. Maybe instead
 * of this algorithm, we need a new type of wrapper in the language to indicate
 * that bytecode segments are intended to go together.
 *
 * Interestingly, we already use "Containers" in both pushes and evaluations, so
 * this might be quite easy. E.g. wrapping with `()` or `{}`. However, we also
 * want disassembled instructions to be valid input in BTL, so some form of this
 * line-based logic will still be required unless we also change script
 * disassembly form. E.g. instead of `OP_PUSHBYTES_2 0x0102`, something like
 * `(OP_PUSHBYTES_2 0x0102)` or `<0x0102>`. This is something to consider in
 * future versions.
 */
// eslint-disable-next-line complexity
const aggregatedParseReductionTraceNodes = (nodes) => {
    const aggregations = [];
    // eslint-disable-next-line functional/no-let
    let ip = 0;
    // eslint-disable-next-line functional/no-let, init-declarations
    let incomplete;
    // eslint-disable-next-line functional/no-loop-statement
    for (const node of nodes) {
        const bytecode = incomplete === undefined
            ? node.bytecode
            : utils_1.flattenBinArray([incomplete.bytecode, node.bytecode]);
        const range = incomplete === undefined
            ? node.range
            : mergeRanges([incomplete.range, node.range]);
        // eslint-disable-next-line functional/no-expression-statement
        incomplete = undefined;
        const parsed = instruction_sets_utils_1.parseBytecode(bytecode);
        // eslint-disable-next-line functional/no-conditional-statement
        if (parsed.length === 0) {
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            aggregations.push({
                instructions: [],
                lastIp: ip,
                range
            });
            // eslint-disable-next-line functional/no-conditional-statement
        }
        else if (instruction_sets_utils_1.authenticationInstructionsAreNotMalformed(parsed)) {
            // eslint-disable-next-line functional/no-expression-statement
            ip += parsed.length;
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            aggregations.push({
                instructions: parsed,
                lastIp: ip,
                range
            });
            // eslint-disable-next-line functional/no-conditional-statement
        }
        else {
            // eslint-disable-next-line functional/no-expression-statement
            incomplete = { bytecode, range };
        }
    }
    return Object.assign({ aggregations, success: true }, (incomplete === undefined
        ? undefined
        : {
            remainingBytecode: incomplete.bytecode,
            remainingRange: incomplete.range,
            success: false
        }));
};
/**
 * Evaluate an array of `InstructionAggregation`s with the provided
 * `AuthenticationVirtualMachine`, matching the results back to their source
 * ranges.
 */
exports.evaluateInstructionAggregations = (aggregations, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, getState) => {
    var _a, _b;
    const nonEmptyAggregations = aggregations.filter(aggregation => aggregation.instructions.length > 0);
    const evaluationPlan = nonEmptyAggregations.reduce((plan, aggregation) => {
        const instructions = [...plan.instructions, ...aggregation.instructions];
        return {
            breakpoints: [
                ...plan.breakpoints,
                { ip: aggregation.lastIp, range: aggregation.range }
            ],
            instructions
        };
    }, { breakpoints: [], instructions: [] });
    const trace = vm.stateDebug(getState(evaluationPlan.instructions));
    const samples = evaluationPlan.breakpoints.map(breakpoint => ({
        range: breakpoint.range,
        state: trace[breakpoint.ip - 1]
    }));
    const firstInvalidSample = samples.findIndex(sample => sample.state === undefined);
    const errorSample = (_a = samples[firstInvalidSample - 1], (_a !== null && _a !== void 0 ? _a : samples[firstInvalidSample]));
    return errorSample === undefined
        ? {
            samples: samples,
            success: true
        }
        : {
            errors: [
                {
                    error: errorSample.state === undefined
                        ? `Failed to reduce evaluation: vm.debug produced no valid program states.`
                        : `Failed to reduce evaluation: ${_b = errorSample.state.error, (_b !== null && _b !== void 0 ? _b : 'unknown error')}`,
                    range: errorSample.range
                }
            ],
            samples,
            success: false
        };
};
/**
 * Incrementally evaluate an array of `ScriptReductionTraceNode`s, returning a
 * trace of the evaluation and the resulting top stack item (`evaluationResult`)
 * if successful.
 *
 * @param nodes an array of reduced nodes
 * @param vm the `AuthenticationVirtualMachine` to use in the evaluation
 * @param getState a method which should generate a new ProgramState given an
 * array of `instructions`
 */
// eslint-disable-next-line complexity
exports.sampledEvaluateReductionTraceNodes = (nodes, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, getState) => {
    const parsed = aggregatedParseReductionTraceNodes(nodes);
    const evaluated = exports.evaluateInstructionAggregations(parsed.aggregations, vm, getState);
    if (parsed.success && evaluated.success) {
        const samples = evaluated.samples.length > 0
            ? evaluated.samples
            : [{ range: parsed.aggregations[0].range, state: getState([]) }];
        const lastSample = samples[samples.length - 1];
        const lastStackItem = lastSample.state.stack[lastSample.state.stack.length - 1];
        const evaluationResult = lastStackItem === undefined ? Uint8Array.of() : lastStackItem.slice();
        return {
            bytecode: evaluationResult,
            samples,
            success: true
        };
    }
    return {
        bytecode: Uint8Array.of(),
        errors: [
            ...(parsed.success
                ? []
                : [
                    {
                        error: `A sample is malformed and cannot be evaluated: ${instruction_sets_utils_1.disassembleBytecode(opcodes_1.OpcodesCommon, parsed.remainingBytecode)}`,
                        range: parsed.remainingRange
                    }
                ]),
            ...(evaluated.success ? [] : evaluated.errors)
        ],
        samples: evaluated.samples,
        success: false
    };
};
/**
 * This method will throw an error if provided a `compiledScript` with
 * compilation errors. To check for compilation errors, use `getCompileErrors`.
 * @param compiledScript the `CompiledScript` to reduce
 * @param vm the `AuthenticationVirtualMachine` to use for evaluations
 * @param createState a method which returns the base `ProgramState` used when initializing evaluations
 */
exports.reduceScript = (compiledScript, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, createState) => {
    const source = compiledScript.map(segment => {
        switch (segment.type) {
            case 'bytecode':
                return { bytecode: segment.value, range: segment.range };
            case 'push': {
                if (segment.value.length === 0) {
                    return emptyReductionTraceNode(segment.range);
                }
                const push = exports.reduceScript(segment.value, vm, createState);
                const bytecode = instruction_sets_1.encodeDataPush(push.bytecode);
                return Object.assign(Object.assign({ bytecode }, (push.errors === undefined ? undefined : { errors: push.errors })), { range: segment.range, source: [push] });
            }
            case 'evaluation': {
                if (segment.value.length === 0) {
                    return emptyReductionTraceNode(segment.range);
                }
                if (typeof vm === 'undefined' || typeof createState === 'undefined') {
                    return Object.assign({ errors: [
                            {
                                error: 'Both a VM and a createState method are required to reduce evaluations.',
                                range: segment.range
                            }
                        ] }, emptyReductionTraceNode(segment.range));
                }
                const reductionTrace = exports.reduceScript(segment.value, vm, createState);
                const evaluated = exports.sampledEvaluateReductionTraceNodes(reductionTrace.source, vm, createState);
                const errors = [
                    ...(reductionTrace.errors === undefined ? [] : reductionTrace.errors),
                    ...(evaluated.success ? [] : evaluated.errors)
                ];
                return Object.assign(Object.assign({}, (errors.length > 0
                    ? Object.assign({ errors }, emptyReductionTraceNode(segment.range)) : {
                    bytecode: evaluated.bytecode,
                    range: segment.range
                })), { samples: evaluated.samples, source: [reductionTrace] });
            }
            case 'comment':
                return emptyReductionTraceNode(segment.range);
            case 'error':
                return Object.assign({ errors: [
                        {
                            error: `Tried to reduce a BTL script with resolution errors: ${segment.value}`,
                            range: segment.range
                        }
                    ] }, emptyReductionTraceNode(segment.range));
            default:
                return new Error(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                `"${segment.type}" is not a known segment type.`);
        }
    });
    const reduction = source.reduce((all, segment) => (Object.assign({ bytecode: [...all.bytecode, segment.bytecode], ranges: [...all.ranges, segment.range] }, (all.errors !== undefined || segment.errors !== undefined
        ? {
            errors: [
                ...(all.errors === undefined ? [] : all.errors),
                ...(segment.errors === undefined ? [] : segment.errors)
            ]
        }
        : undefined))), { bytecode: [], ranges: [] });
    return Object.assign(Object.assign({}, (reduction.errors === undefined
        ? undefined
        : { errors: reduction.errors })), { bytecode: utils_1.flattenBinArray(reduction.bytecode), range: mergeRanges(reduction.ranges), source });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9hdXRoL3RlbXBsYXRlcy9sYW5ndWFnZS9yZWR1Y2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxnREFBdUQ7QUFDdkQsbUVBQXNFO0FBQ3RFLDhFQUF5RTtBQUV6RSwwRkFJdUQ7QUFPdkQsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1QyxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVc7SUFDOUIsZUFBZSxFQUFFLEtBQUssQ0FBQyxlQUFlO0NBQ3ZDLENBQUMsQ0FBQztBQUVILE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTO0lBQzFCLGFBQWEsRUFBRSxLQUFLLENBQUMsYUFBYTtDQUNuQyxDQUFDLENBQUM7QUFFSCxNQUFNLFdBQVcsR0FBRyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ3RDLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxNQUFNO0lBQ2xDLHNDQUFzQztJQUN0QyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLGlDQUNkLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBZTtRQUNoRCxDQUFDLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDO1FBQzNCLENBQUMsQ0FBQyxLQUFLLENBQUMsZUFBZSxLQUFLLE1BQU0sQ0FBQyxlQUFlO1lBQ2hELEtBQUssQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVc7WUFDeEMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQztZQUMzQixDQUFDLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsR0FDNUIsQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxhQUFhO1FBQzVDLENB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