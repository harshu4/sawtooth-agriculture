import { AuthenticationInstruction, ParsedAuthenticationInstruction, ParsedAuthenticationInstructionMalformed, ParsedAuthenticationInstructions } from './instruction-sets-types';
export declare const authenticationInstructionIsMalformed: <Opcodes>(instruction: ParsedAuthenticationInstruction<Opcodes>) => instruction is ParsedAuthenticationInstructionMalformed<Opcodes>;
export declare const authenticationInstructionsAreMalformed: <Opcodes>(instructions: ParsedAuthenticationInstructions<Opcodes>) => instructions is ParsedAuthenticationInstructionMalformed<Opcodes>[];
export declare const authenticationInstructionsAreNotMalformed: <Opcodes>(instructions: ParsedAuthenticationInstructions<Opcodes>) => instructions is AuthenticationInstruction<Opcodes>[];
declare enum Bytes {
    Uint8 = 1,
    Uint16 = 2,
    Uint32 = 4
}
/**
 * Note: this implementation assumes `script` is defined and long enough to read
 * the specified number of bytes. If necessary, validation should be done before
 * calling this method.
 *
 * @param script the Uint8Array from which to read
 * @param index the index from which to begin reading
 * @param length the number of bytes to read
 */
export declare const readLittleEndianNumber: (script: Uint8Array, index: number, length: Bytes) => number;
/**
 * Note: this implementation assumes `script` is defined and long enough to
 * write the specified number of bytes. It also assumes the provided `number` is
 * representable in `length` bytes.
 *
 * If necessary, validation should be done before calling this method.
 *
 * @param script the Uint8Array to which the number should be written
 * @param index the index at which to begin reading
 * @param length the number of bytes to use
 * @param value the number to write at `script[index]`
 */
export declare const writeLittleEndianNumber: (script: Uint8Array, index: number, length: Bytes, value: number) => Uint8Array;
export declare const numberToLittleEndianBin: (value: number, length: Bytes) => Uint8Array;
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode an opcode between 0x00 and 0x4e
 */
export declare const lengthBytesForPushOpcode: (opcode: number) => number;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script the script from which to read the next instruction
 * @param index the offset from which to begin reading
 */
export declare const readAuthenticationInstruction: <Opcodes = number>(script: Uint8Array, index: number) => {
    readonly instruction: ParsedAuthenticationInstruction<Opcodes>;
    readonly nextIndex: number;
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script the serialized script to parse
 */
export declare const parseBytecode: <Opcodes = number>(script: Uint8Array) => ParsedAuthenticationInstructions<Opcodes>;
export declare const disassembleParsedAuthenticationInstructionMalformed: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instruction: ParsedAuthenticationInstructionMalformed<Opcodes>) => string;
export declare const disassembleAuthenticationInstruction: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instruction: AuthenticationInstruction<Opcodes>) => string;
export declare const disassembleParsedAuthenticationInstruction: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instruction: ParsedAuthenticationInstruction<Opcodes>) => string;
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script the array of instructions to disassemble
 */
export declare const disassembleParsedAuthenticationInstructions: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instructions: readonly ParsedAuthenticationInstruction<Opcodes>[]) => string;
/**
 * Disassemble authentication bytecode into a lossless ASM representation.
 *
 * TODO: a similar method which re-formats ASM strings, converting HexLiterals to Script Numbers or UTF8Literals.
 *
 * @param opcodes the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode the authentication bytecode to disassemble
 */
export declare const disassembleBytecode: <Opcode = number>(opcodes: {
    readonly [opcode: number]: string;
}, bytecode: Uint8Array) => string;
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */
export declare const disassembleBytecodeBCH: (bytecode: Uint8Array) => string;
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */
export declare const disassembleBytecodeBTC: (bytecode: Uint8Array) => string;
export declare const serializeAuthenticationInstruction: <Opcodes = number>(instruction: AuthenticationInstruction<Opcodes>) => Uint8Array;
export declare const serializeParsedAuthenticationInstructionMalformed: <Opcodes = number>(instruction: ParsedAuthenticationInstructionMalformed<Opcodes>) => Uint8Array;
export declare const serializeParsedAuthenticationInstruction: <Opcodes = number>(instruction: ParsedAuthenticationInstruction<Opcodes>) => Uint8Array;
export declare const serializeAuthenticationInstructions: <Opcodes = number>(instructions: readonly AuthenticationInstruction<Opcodes>[]) => Uint8Array;
export declare const serializeParsedAuthenticationInstructions: <Opcodes = number>(instructions: readonly ParsedAuthenticationInstruction<Opcodes>[]) => Uint8Array;
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes An opcode enum, e.g. `OpcodesBCH`
 */
export declare const generateBytecodeMap: (opcodes: object) => {
    [opcode: string]: Uint8Array;
};
export {};
//# sourceMappingURL=instruction-sets-utils.d.ts.map