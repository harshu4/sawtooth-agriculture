import { Secp256k1, Sha256 } from '../../../crypto/crypto';
import { AuthenticationInstruction } from '../../instruction-sets/instruction-sets-types';
import { AuthenticationVirtualMachine } from '../../virtual-machine';
import { AuthenticationTemplateVariable } from '../types';
import { CompilationResultSuccess } from './compile';
import { BtlScriptSegment } from './parse';
export interface Range {
    endColumn: number;
    endLineNumber: number;
    startColumn: number;
    startLineNumber: number;
}
interface ResolvedSegmentBase {
    range: Range;
    type: string;
}
export interface ResolvedSegmentPush<T> extends ResolvedSegmentBase {
    type: 'push';
    value: T;
}
export interface ResolvedSegmentEvaluation<T> extends ResolvedSegmentBase {
    type: 'evaluation';
    value: T;
}
export interface ResolvedSegmentVariableBytecode extends ResolvedSegmentBase {
    type: 'bytecode';
    value: Uint8Array;
    variable: string;
}
export interface ResolvedSegmentScriptBytecode extends ResolvedSegmentBase {
    script: string;
    source: ResolvedScript;
    type: 'bytecode';
    value: Uint8Array;
}
export interface ResolvedSegmentOpcodeBytecode extends ResolvedSegmentBase {
    opcode: string;
    type: 'bytecode';
    value: Uint8Array;
}
export interface ResolvedSegmentLiteralBytecode extends ResolvedSegmentBase {
    literalType: 'BigIntLiteral' | 'HexLiteral' | 'UTF8Literal';
    type: 'bytecode';
    value: Uint8Array;
}
export declare type ResolvedSegmentBytecode = ResolvedSegmentLiteralBytecode | ResolvedSegmentOpcodeBytecode | ResolvedSegmentScriptBytecode | ResolvedSegmentVariableBytecode;
export interface ResolvedSegmentComment extends ResolvedSegmentBase {
    type: 'comment';
    value: string;
}
export interface ResolvedSegmentError extends ResolvedSegmentBase {
    type: 'error';
    value: string;
}
export declare type ResolvedSegment = ResolvedSegmentPush<ResolvedScript> | ResolvedSegmentEvaluation<ResolvedScript> | ResolvedSegmentBytecode | ResolvedSegmentComment | ResolvedSegmentError;
export interface ResolvedScript extends Array<ResolvedSegment> {
}
export declare enum IdentifierResolutionType {
    opcode = "opcode",
    variable = "variable",
    script = "script"
}
export declare type IdentifierResolutionFunction = (identifier: string) => {
    bytecode: Uint8Array;
    status: true;
    type: IdentifierResolutionType.opcode | IdentifierResolutionType.variable;
} | {
    bytecode: Uint8Array;
    source: ResolvedScript;
    status: true;
    type: IdentifierResolutionType.script;
} | {
    error: string;
    status: false;
};
export declare const resolveScriptSegment: (segment: BtlScriptSegment, resolveIdentifiers: IdentifierResolutionFunction) => ResolvedScript;
export declare type CompilerOperationTypes = AuthenticationTemplateVariable['type'] | 'SigningSerialization';
/**
 * Returns the bytecode result on success or an error message on failure.
 */
export declare type CompilerOperation<CompilerOperationData = {}, Checked extends CompilerOperationTypes | undefined = undefined> = (identifier: string, compilationData: Checked extends 'Key' ? Required<Pick<CompilationData<CompilerOperationData>, 'keys'>> & CompilationData<CompilerOperationData> : Checked extends 'HDKey' ? Required<Pick<CompilationData<CompilerOperationData>, 'hdKeys'>> & CompilationData<CompilerOperationData> : Checked extends 'WalletData' ? Required<Pick<CompilationData<CompilerOperationData>, 'walletData'>> & CompilationData<CompilerOperationData> : Checked extends 'AddressData' ? Required<Pick<CompilationData<CompilerOperationData>, 'addressData'>> & CompilationData<CompilerOperationData> : CompilationData<CompilerOperationData>, compilationEnvironment: CompilationEnvironment<CompilerOperationData>) => Uint8Array | string;
export declare type CompilerOperationsMinimal = 'public_key' | 'signature';
/**
 * The full context required to compile a given Bitauth Template – everything
 * required for the compiler to generate the final script code (targeting a
 * specific `AuthenticationVirtualMachine`).
 *
 * A `CompilationEnvironment` must include a subset of the script's
 * `AuthenticationTemplate` – all the variables and scripts referenced
 * (including children of children) by the script in question.
 *
 * The context must also include an object mapping of opcode identifiers to the
 * bytecode they generate.
 *
 * If keys are used, an implementation of `sha256` and `secp256k1` is
 * required. If the script requires evaluations during compilation, the
 * evaluating `AuthenticationVirtualMachine` must also be included.
 */
export interface CompilationEnvironment<CompilerOperationData = {}, CompilerOperations extends string = CompilerOperationsMinimal> {
    /**
     * A method which accepts an array of `AuthenticationInstruction`s, and
     * returns a ProgramState. This method will be used to generate the initial
     * ProgramState for `evaluation`s.
     */
    createState?: (instructions: AuthenticationInstruction<any>[]) => any;
    /**
     * An object mapping opcode identifiers to the bytecode they generate.
     */
    opcodes?: {
        [opcodeIdentifier: string]: Uint8Array;
    };
    /**
     * An object specifying the operations made available by this
     * CompilationEnvironment for each variable type, e.g. keys may support public
     * key derivation and multiple signature types.
     */
    operations?: {
        [key in CompilerOperationTypes]?: {
            [operationId in CompilerOperations]?: CompilerOperation<CompilerOperationData, key>;
        };
    };
    /**
     * An object mapping script identifiers to the text of script in Bitauth
     * Templating Language.
     *
     * To avoid compilation errors, this object must contain all scripts
     * referenced by the script being compiled (including children of children).
     */
    scripts: {
        [scriptId: string]: string;
    };
    /**
     * An implementation of secp256k1 is required for any scripts which include
     * signatures.
     */
    secp256k1?: Secp256k1;
    /**
     * An implementation of sha256 is required for any scripts which include
     * signatures.
     */
    sha256?: Sha256;
    /**
     * The "breadcrumb" path of script IDs currently being resolved. (E.g.
     * `["grandparentId", "parentId"]`) BTL identifier resolution must be acyclic.
     *
     * To prevent an infinite loop, `IdentifierResolutionFunction`s must abort
     * resolution if they encounter their own `id` while resolving another
     * identifier. Likewise, child scripts being resolved by a parent script
     * may not reference any script which is already in the process of being
     * resolved.
     */
    sourceScriptIds?: string[];
    /**
     * An object mapping Bitauth variable identifiers to the
     * `AuthenticationTemplateVariable` describing them.
     *
     * To avoid compilation errors, this object must contain all variables
     * referenced by the script being compiled (including in child scripts).
     */
    variables?: {
        [variableId: string]: AuthenticationTemplateVariable;
    };
    /**
     * The AuthenticationVirtualMachine on which BTL `evaluation` results will be
     * computed.
     */
    vm?: AuthenticationVirtualMachine<any, any>;
}
export interface CompilationData<CompilerOperationData> {
    addressData?: {
        [id: string]: Uint8Array;
    };
    currentBlockHeight?: number;
    currentBlockTime?: Date;
    /**
     * TODO: implement `HDKeys` support (similar to `keys`, `HDKeys` simply takes `index` and `derivationHardened` into account. Note: no current plans to support more complex paths, users needing that kind of control should use `keys` manually.)
     */
    hdKeys?: {
        /**
         * TODO: describe that `derivationHardened` and `index` refer to the script derivation index and hardening settings. (The parent account is controlled by `templateDerivationIndex` and `templateDerivationHardened` in `CompilerEnvironment.variables`)
         */
        derivationHardened?: boolean;
        index: number;
        privateHdKeys?: {
            [id: string]: Uint8Array;
        };
        publicHdKeys?: {
            [id: string]: Uint8Array;
        };
        signatures?: {
            [id: string]: Uint8Array;
        };
    };
    keys?: {
        privateKeys?: {
            [id: string]: Uint8Array;
        };
        publicKeys?: {
            [id: string]: Uint8Array;
        };
        /**
         * Signatures provided to us by other entities. Since we don't have their
         * private key, we'll need them to send us a valid signature to include in
         * the proper spots. The provided `id` should match the full identifier for
         * the signature, e.g. `variable.signature.all_outputs`.
         */
        signatures?: {
            [id: string]: Uint8Array;
        };
    };
    operationData?: CompilerOperationData;
    walletData?: {
        [id: string]: Uint8Array;
    };
}
export declare enum BuiltInVariables {
    currentBlockTime = "current_block_time",
    currentBlockHeight = "current_block_height",
    signingSerialization = "signing_serialization"
}
/**
 * If the identifer can be successfully resolved as a variable, the result is
 * returned as a Uint8Array. If the identifier references a known variable, but
 * an error occurs in resolving it, the error is returned as a string.
 * Otherwise, the identifier is not recognized as a variable, and this method
 * simply returns `false`.
 */
export declare const resolveAuthenticationTemplateVariable: <CompilerOperationData>(identifier: string, environment: CompilationEnvironment<CompilerOperationData, CompilerOperationsMinimal>, data: CompilationData<CompilerOperationData>) => string | false | Uint8Array;
/**
 * Compile an internal script identifier.
 *
 * @remarks
 * If the identifer can be successfully resolved as a script, the script is
 * compiled and returned as a CompilationResultSuccess. If an error occurs in
 * compiling it, the error is returned as a string.
 *
 * Otherwise, the identifier is not recognized as a script, and this method
 * simply returns `false`.
 *
 * @param identifier the identifier of the script to be resolved
 * @param data the provided CompilationData
 * @param environment the provided CompilationEnvironment
 * @param parentIdentifier the identifier of the script which references the
 * script being resolved (for detecting circular dependencies)
 */
export declare const resolveScriptIdentifier: <CompilerOperationData, ProgramState>(identifier: string, data: CompilationData<CompilerOperationData>, environment: CompilationEnvironment<CompilerOperationData, CompilerOperationsMinimal>, parentIdentifier?: string | undefined) => string | false | CompilationResultSuccess<ProgramState>;
/**
 * Return an `IdentifierResolutionFunction` for use in `resolveScriptSegment`.
 *
 * @param scriptId the `id` of the script for which the resulting
 * `IdentifierResolutionFunction` will be used.
 * @param environment a snapshot of the context around `scriptId`. See
 * `CompilationEnvironment` for details.
 * @param data the actual variable values (private keys, shared wallet data,
 * shared address data, etc.) to use in resolving variables.
 */
export declare const createIdentifierResolver: <CompilerOperationData>(scriptId: string | undefined, data: CompilationData<CompilerOperationData>, environment: CompilationEnvironment<CompilerOperationData, CompilerOperationsMinimal>) => IdentifierResolutionFunction;
export {};
//# sourceMappingURL=resolve.d.ts.map