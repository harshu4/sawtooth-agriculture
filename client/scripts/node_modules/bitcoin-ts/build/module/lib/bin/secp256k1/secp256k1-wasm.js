/* eslint-disable no-underscore-dangle */
// cSpell:ignore memcpy, anyfunc
import { base64ToBin } from '../../utils/utils';
import { CompressionFlag, ContextFlag } from './secp256k1-wasm-types';
import { secp256k1Base64Bytes } from './secp256k1.base64';
export { ContextFlag, CompressionFlag };
/* eslint-disable @typescript-eslint/no-explicit-any */
const wrapSecp256k1Wasm = (instance, heapU8, heapU32) => ({
    contextCreate: context => instance.exports._secp256k1_context_create(context),
    contextRandomize: (contextPtr, seedPtr) => instance.exports._secp256k1_context_randomize(contextPtr, seedPtr),
    free: pointer => instance.exports._free(pointer),
    heapU32,
    heapU8,
    instance,
    malloc: bytes => instance.exports._malloc(bytes),
    mallocSizeT: num => {
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        const pointer = instance.exports._malloc(4);
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
        const pointerView32 = pointer >> 2;
        // eslint-disable-next-line functional/no-expression-statement
        heapU32.set([num], pointerView32);
        return pointer;
    },
    mallocUint8Array: array => {
        const pointer = instance.exports._malloc(array.length);
        // eslint-disable-next-line functional/no-expression-statement
        heapU8.set(array, pointer);
        return pointer;
    },
    privkeyTweakAdd: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_add(contextPtr, secretKeyPtr, tweakNum256Ptr),
    privkeyTweakMul: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_mul(contextPtr, secretKeyPtr, tweakNum256Ptr),
    pubkeyCreate: (contextPtr, publicKeyPtr, secretKeyPtr) => instance.exports._secp256k1_ec_pubkey_create(contextPtr, publicKeyPtr, secretKeyPtr),
    pubkeyParse: (contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength) => instance.exports._secp256k1_ec_pubkey_parse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength),
    pubkeySerialize: (contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression) => instance.exports._secp256k1_ec_pubkey_serialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression),
    pubkeyTweakAdd: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_add(contextPtr, publicKeyPtr, tweakNum256Ptr),
    pubkeyTweakMul: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_mul(contextPtr, publicKeyPtr, tweakNum256Ptr),
    readHeapU8: (pointer, bytes) => new Uint8Array(heapU8.buffer, pointer, bytes),
    readSizeT: pointer => {
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
        const pointerView32 = pointer >> 2;
        return heapU32[pointerView32];
    },
    recover: (contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr) => instance.exports._secp256k1_ecdsa_recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr),
    recoverableSignatureParse: (contextPtr, outputRSigPtr, inputSigPtr, rid) => instance.exports._secp256k1_ecdsa_recoverable_signature_parse_compact(contextPtr, outputRSigPtr, inputSigPtr, rid),
    recoverableSignatureSerialize: (contextPtr, sigOutPtr, recIDOutPtr, rSigPtr) => instance.exports._secp256k1_ecdsa_recoverable_signature_serialize_compact(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr),
    schnorrSign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_schnorr_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
    schnorrVerify: (contextPtr, sigPtr, msg32Ptr, publicKeyPtr) => instance.exports._secp256k1_schnorr_verify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr),
    seckeyVerify: (contextPtr, secretKeyPtr) => instance.exports._secp256k1_ec_seckey_verify(contextPtr, secretKeyPtr),
    sign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
    signRecoverable: (contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign_recoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr),
    signatureMalleate: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_malleate(contextPtr, outputSigPtr, inputSigPtr),
    signatureNormalize: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_normalize(contextPtr, outputSigPtr, inputSigPtr),
    signatureParseCompact: (contextPtr, sigOutPtr, compactSigInPtr) => instance.exports._secp256k1_ecdsa_signature_parse_compact(contextPtr, sigOutPtr, compactSigInPtr),
    signatureParseDER: (contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength) => instance.exports._secp256k1_ecdsa_signature_parse_der(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength),
    signatureSerializeCompact: (contextPtr, outputCompactSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_compact(contextPtr, outputCompactSigPtr, inputSigPtr),
    signatureSerializeDER: (contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_der(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr),
    verify: (contextPtr, sigPtr, msg32Ptr, pubkeyPtr) => instance.exports._secp256k1_ecdsa_verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr)
});
/* eslint-enable @typescript-eslint/no-explicit-any */
/* eslint-disable functional/immutable-data, functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/no-conditional-statement, no-bitwise, functional/no-throw-statement */
/**
 * Method extracted from Emscripten's preamble.js
 */
const isLittleEndian = (buffer) => {
    const littleEndian = true;
    const notLittleEndian = false;
    const heap16 = new Int16Array(buffer);
    const heap32 = new Int32Array(buffer);
    const heapU8 = new Uint8Array(buffer);
    heap32[0] = 1668509029;
    heap16[1] = 25459;
    return heapU8[2] !== 115 || heapU8[3] !== 99
        ? /* istanbul ignore next */ notLittleEndian
        : littleEndian;
};
/**
 * Method derived from Emscripten's preamble.js
 */
const alignMemory = (factor, size) => Math.ceil(size / factor) * factor;
/**
 * The most performant way to instantiate secp256k1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use `instantiateSecp256k1`.
 *
 * Note, most of this method is translated and boiled-down from Emscripten's
 * preamble.js. Significant changes to the WASM build or breaking updates to
 * Emscripten will likely require modifications to this method.
 *
 * @param webassemblyBytes A buffer containing the secp256k1 binary.
 */
export const instantiateSecp256k1WasmBytes = async (webassemblyBytes) => {
    const STACK_ALIGN = 16;
    const GLOBAL_BASE = 1024;
    const WASM_PAGE_SIZE = 65536;
    const TOTAL_STACK = 5242880;
    const TOTAL_MEMORY = 16777216;
    const wasmMemory = new WebAssembly.Memory({
        initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
        maximum: TOTAL_MEMORY / WASM_PAGE_SIZE
    });
    /* istanbul ignore if  */
    if (!isLittleEndian(wasmMemory.buffer)) {
        /*
         * note: this block is excluded from test coverage. It's A) hard to test
         * (must be either tested on big-endian hardware or a big-endian buffer
         * mock) and B) extracted from Emscripten's preamble.js, where it should
         * be tested properly.
         */
        throw new Error('Runtime error: expected the system to be little-endian.');
    }
    const STATIC_BASE = GLOBAL_BASE;
    const STATICTOP_INITIAL = STATIC_BASE + 67696 + 16;
    const DYNAMICTOP_PTR = STATICTOP_INITIAL;
    const DYNAMICTOP_PTR_SIZE = 4;
    const STATICTOP = (STATICTOP_INITIAL + DYNAMICTOP_PTR_SIZE + 15) & -16;
    const STACKTOP = alignMemory(STACK_ALIGN, STATICTOP);
    const STACK_BASE = STACKTOP;
    const STACK_MAX = STACK_BASE + TOTAL_STACK;
    const DYNAMIC_BASE = alignMemory(STACK_ALIGN, STACK_MAX);
    const heapU8 = new Uint8Array(wasmMemory.buffer);
    const heap32 = new Int32Array(wasmMemory.buffer);
    const heapU32 = new Uint32Array(wasmMemory.buffer);
    heap32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
    const TABLE_SIZE = 6;
    const MAX_TABLE_SIZE = 6;
    // eslint-disable-next-line functional/no-let, init-declarations
    let getErrNoLocation;
    /*
     * note: A number of methods below are excluded from test coverage. They are
     * a) not part of the regular usage of this library (should only be evaluated
     * if the consumer mis-implements the library and exist only to make
     * debugging easier) and B) already tested adequately in Emscripten, from
     * which this section is extracted.
     */
    const env = {
        DYNAMICTOP_PTR,
        STACKTOP,
        ___setErrNo: /* istanbul ignore next */ (value) => {
            if (getErrNoLocation !== undefined) {
                heap32[getErrNoLocation() >> 2] = value;
            }
            return value;
        },
        _abort: /* istanbul ignore next */ (err = 'Secp256k1 Error') => {
            throw new Error(err);
        },
        // eslint-disable-next-line camelcase
        _emscripten_memcpy_big: /* istanbul ignore next */ (dest, src, num) => {
            heapU8.set(heapU8.subarray(src, src + num), dest);
            return dest;
        },
        abort: /* istanbul ignore next */ (err = 'Secp256k1 Error') => {
            throw new Error(err);
        },
        abortOnCannotGrowMemory: /* istanbul ignore next */ () => {
            throw new Error('Secp256k1 Error: abortOnCannotGrowMemory was called.');
        },
        enlargeMemory: /* istanbul ignore next */ () => {
            throw new Error('Secp256k1 Error: enlargeMemory was called.');
        },
        getTotalMemory: () => TOTAL_MEMORY
    };
    const info = {
        env: {
            ...env,
            memory: wasmMemory,
            memoryBase: STATIC_BASE,
            table: new WebAssembly.Table({
                element: 'anyfunc',
                initial: TABLE_SIZE,
                maximum: MAX_TABLE_SIZE
            }),
            tableBase: 0
        },
        global: { Infinity, NaN }
    };
    return WebAssembly.instantiate(webassemblyBytes, info).then(result => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        getErrNoLocation = result.instance.exports.___errno_location;
        return wrapSecp256k1Wasm(result.instance, heapU8, heapU32);
    });
};
/* eslint-enable functional/immutable-data, functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/no-conditional-statement, no-bitwise, functional/no-throw-statement */
export const getEmbeddedSecp256k1Binary = () => base64ToBin(secp256k1Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of `instantiateSecp256k1Bytes`
 * which does not require the consumer to provide the secp256k1 binary buffer.
 */
export const instantiateSecp256k1Wasm = async () => instantiateSecp256k1WasmBytes(getEmbeddedSecp256k1Binary());
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLXdhc20uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2Jpbi9zZWNwMjU2azEvc2VjcDI1NmsxLXdhc20udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDO0FBQ3pDLGdDQUFnQztBQUNoQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFaEQsT0FBTyxFQUNMLGVBQWUsRUFDZixXQUFXLEVBRVosTUFBTSx3QkFBd0IsQ0FBQztBQUNoQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUUxRCxPQUFPLEVBQUUsV0FBVyxFQUFFLGVBQWUsRUFBaUIsQ0FBQztBQUV2RCx1REFBdUQ7QUFDdkQsTUFBTSxpQkFBaUIsR0FBRyxDQUN4QixRQUE4QixFQUM5QixNQUFrQixFQUNsQixPQUFvQixFQUNMLEVBQUUsQ0FBQyxDQUFDO0lBQ25CLGFBQWEsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUN0QixRQUFRLENBQUMsT0FBZSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQztJQUM5RCxnQkFBZ0IsRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUN2QyxRQUFRLENBQUMsT0FBZSxDQUFDLDRCQUE0QixDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUM7SUFFN0UsSUFBSSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUUsUUFBUSxDQUFDLE9BQWUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO0lBQ3pELE9BQU87SUFDUCxNQUFNO0lBQ04sUUFBUTtJQUNSLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFFLFFBQVEsQ0FBQyxPQUFlLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUN6RCxXQUFXLEVBQUUsR0FBRyxDQUFDLEVBQUU7UUFDakIsK0RBQStEO1FBQy9ELE1BQU0sT0FBTyxHQUFJLFFBQVEsQ0FBQyxPQUFlLENBQUMs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