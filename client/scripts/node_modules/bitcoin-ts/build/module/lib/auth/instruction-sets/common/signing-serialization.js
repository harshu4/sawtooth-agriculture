import { bigIntToBinUint64LE, bigIntToBitcoinVarInt, numberToBinUint32LE } from '../../../utils/utils';
/* eslint-disable camelcase */
/**
 * A.K.A. `sighash` flags
 */
export var SigningSerializationFlag;
(function (SigningSerializationFlag) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationFlag[SigningSerializationFlag["all_outputs"] = 1] = "all_outputs";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationFlag[SigningSerializationFlag["no_outputs"] = 2] = "no_outputs";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationFlag[SigningSerializationFlag["corresponding_output"] = 3] = "corresponding_output";
    SigningSerializationFlag[SigningSerializationFlag["fork_id"] = 64] = "fork_id";
    /**
     * A.K.A `ANYONE_CAN_PAY`
     */
    SigningSerializationFlag[SigningSerializationFlag["single_input"] = 128] = "single_input";
})(SigningSerializationFlag || (SigningSerializationFlag = {}));
export const isDefinedSigningSerializationType = (byte) => {
    const baseType = 
    // eslint-disable-next-line no-bitwise
    byte &
        // eslint-disable-next-line no-bitwise
        ~(SigningSerializationFlag.fork_id | SigningSerializationFlag.single_input);
    return (baseType >= SigningSerializationFlag.all_outputs &&
        baseType <= SigningSerializationFlag.corresponding_output);
};
const match = (type, flag) => 
// eslint-disable-next-line no-bitwise
(type[0] & flag) !== 0;
const equals = (type, flag
// eslint-disable-next-line no-bitwise
) => (type[0] & 31 /* mask5Bits */) === flag;
const shouldSerializeSingleInput = (type) => match(type, SigningSerializationFlag.single_input);
const shouldSerializeCorrespondingOutput = (type) => equals(type, SigningSerializationFlag.corresponding_output);
const shouldSerializeNoOutputs = (type) => equals(type, SigningSerializationFlag.no_outputs);
const emptyHash = () => new Uint8Array(32 /* sha256HashByteLength */).fill(0);
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutpoints see `generateSigningSerializationBCH`
 */
export const hashPrevouts = (sha256, signingSerializationType, transactionOutpoints) => shouldSerializeSingleInput(signingSerializationType)
    ? emptyHash()
    : sha256.hash(sha256.hash(transactionOutpoints));
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionSequenceNumbers see
 * `generateSigningSerializationBCH`
 */
export const hashSequence = (sha256, signingSerializationType, transactionSequenceNumbers) => !shouldSerializeSingleInput(signingSerializationType) &&
    !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionSequenceNumbers))
    : emptyHash();
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutputs see `generateSigningSerializationBCH`
 * @param correspondingOutput see `generateSigningSerializationBCH`
 */
export const hashOutputs = (sha256, signingSerializationType, transactionOutputs, correspondingOutput) => !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionOutputs))
    : shouldSerializeCorrespondingOutput(signingSerializationType)
        ? correspondingOutput === undefined
            ? emptyHash()
            : sha256.hash(sha256.hash(correspondingOutput))
        : emptyHash();
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * @param version the version number of the transaction
 * @param transactionOutpoints the serialization of all input outpoints (A.K.A.
 * `hashPrevouts`) – used if `ANYONECANPAY` is not set
 * @param transactionSequenceNumbers the serialization of all input sequence
 * numbers. (A.K.A. `hashSequence`) – used if none of `ANYONECANPAY`, `SINGLE`,
 * or `NONE` are set.
 * @param outpointTransactionHash the big-endian (standard) transaction hash of
 * the outpoint being spent.
 * @param outpointIndex the index of the outpoint being spent in
 * `outpointTransactionHash`
 * @param coveredBytecode the script currently being executed, beginning at the
 * `lastCodeSeparator`.
 * @param outputValue the value of the outpoint in satoshis
 * @param sequenceNumber the sequence number of the input (A.K.A. `nSequence`)
 * @param correspondingOutput the serialization of the output at the same index
 * as this input (A.K.A. `hashOutputs` with `SIGHASH_SINGLE`) – only used if
 * `SINGLE` is set
 * @param transactionOutputs the serialization of output amounts and locking
 * bytecode values (A.K.A. `hashOutputs` with `SIGHASH_ALL`) – only used if
 * `ALL` is set
 * @param locktime the locktime of the transaction
 * @param signingSerializationType the signing serialization type of the
 * signature (A.K.A. `sighash` type)
 * @param forkId while a bitcoin-encoded signature only includes a single byte
 * to encode the signing serialization type, a 3-byte forkId can be appended to
 * provide replay-protection between different forks. (See Bitcoin Cash's Replay
 * Protected Sighash spec for details.)
 */
export const generateSigningSerializationBCH = (sha256, version, transactionOutpoints, transactionSequenceNumbers, outpointTransactionHash, outpointIndex, coveredBytecode, outputValue, sequenceNumber, correspondingOutput, transactionOutputs, locktime, signingSerializationType, forkId = new Uint8Array([0, 0, 0])) => new Uint8Array([
    ...numberToBinUint32LE(version),
    ...hashPrevouts(sha256, signingSerializationType, transactionOutpoints),
    ...hashSequence(sha256, signingSerializationType, transactionSequenceNumbers),
    ...outpointTransactionHash.slice().reverse(),
    ...numberToBinUint32LE(outpointIndex),
    ...Uint8Array.from([
        ...bigIntToBitcoinVarInt(BigInt(coveredBytecode.length)),
        ...coveredBytecode
    ]),
    ...bigIntToBinUint64LE(outputValue),
    ...numberToBinUint32LE(sequenceNumber),
    ...hashOutputs(sha256, signingSerializationType, transactionOutputs, correspondingOutput),
    ...numberToBinUint32LE(locktime),
    ...signingSerializationType,
    ...forkId
]);
/**
 * @param signingSerializationType the 32-bit number indicating the signing
 * serialization algorithm to use
 */
export const isLegacySigningSerialization = (signingSerializationType) => {
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const forkValue = signingSerializationType >> 8;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const newForkValue = (forkValue ^ 0xdead) | 0xff0000;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const sighashType = (newForkValue << 8) | (signingSerializationType & 0xff);
    // eslint-disable-next-line no-bitwise
    return (sighashType & SigningSerializationFlag.fork_id) === 0;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmluZy1zZXJpYWxpemF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9hdXRoL2luc3RydWN0aW9uLXNldHMvY29tbW9uL3NpZ25pbmctc2VyaWFsaXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLHFCQUFxQixFQUNyQixtQkFBbUIsRUFDcEIsTUFBTSxzQkFBc0IsQ0FBQztBQUU5Qiw4QkFBOEI7QUFDOUI7O0dBRUc7QUFDSCxNQUFNLENBQU4sSUFBWSx3QkFrQlg7QUFsQkQsV0FBWSx3QkFBd0I7SUFDbEM7O09BRUc7SUFDSCxxRkFBa0IsQ0FBQTtJQUNsQjs7T0FFRztJQUNILG1GQUFpQixDQUFBO0lBQ2pCOztPQUVHO0lBQ0gsdUdBQTJCLENBQUE7SUFDM0IsOEVBQWMsQ0FBQTtJQUNkOztPQUVHO0lBQ0gseUZBQW1CLENBQUE7QUFDckIsQ0FBQyxFQWxCVyx3QkFBd0IsS0FBeEIsd0JBQXdCLFFBa0JuQztBQVFELE1BQU0sQ0FBQyxNQUFNLGlDQUFpQyxHQUFHLENBQUMsSUFBWSxFQUFFLEVBQUU7SUFDaEUsTUFBTSxRQUFRO0lBQ1osc0NBQXNDO0lBQ3RDLElBQUk7UUFDSixzQ0FBc0M7UUFDdEMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLE9BQU8sR0FBRyx3QkFBd0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM5RSxPQUFPLENBQ0wsUUFBUSxJQUFJLHdCQUF3QixDQUFDLFdBQVc7UUFDaEQsUUFBUSxJQUFJLHdCQUF3QixDQUFDLG9CQUFvQixDQUMxRCxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUYsTUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFnQixFQUFFLElBQThCLEVBQUUsRUFBRTtBQUNqRSxzQ0FBc0M7QUFDdEMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBRXpC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