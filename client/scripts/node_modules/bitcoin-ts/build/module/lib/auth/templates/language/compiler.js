import { instantiateSecp256k1, instantiateSha256 } from '../../../crypto/crypto';
import { bigIntToBinUint64LE, bigIntToBitcoinVarInt, numberToBinUint32LE } from '../../../utils/utils';
import { generateSigningSerializationBCH, SigningSerializationFlag } from '../../instruction-sets/common/signing-serialization';
import { createAuthenticationProgramExternalStateCommonEmpty, createAuthenticationProgramStateCommon, generateBytecodeMap, instantiateVirtualMachineBCH, instructionSetBCHCurrentStrict, OpcodesBCH } from '../../instruction-sets/instruction-sets';
import { compileScript } from './compile';
import { resolveScriptIdentifier } from './resolve';
/* eslint-disable camelcase */
export var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs"] = "all_outputs";
    /**
     * A.K.A. `SIGHASH_ALL|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs_single_input"] = "all_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output"] = "corresponding_output";
    /**
     * A.K.A. `SIGHASH_SINGLE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output_single_input"] = "corresponding_output_single_input";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs"] = "no_outputs";
    /**
     * A.K.A `SIGHASH_NONE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs_single_input"] = "no_outputs_single_input";
})(SigningSerializationAlgorithmIdentifier || (SigningSerializationAlgorithmIdentifier = {}));
var ScriptGenerationError;
(function (ScriptGenerationError) {
    ScriptGenerationError["missingVm"] = "An evaluation is required, but no VM was provided.";
    ScriptGenerationError["missingSha256"] = "Sha256 is required, but no implementation was provided.";
    ScriptGenerationError["missingSecp256k1"] = "Secp256k1 is required, but no implementation was provided.";
})(ScriptGenerationError || (ScriptGenerationError = {}));
// eslint-disable-next-line complexity
const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
    switch (algorithmIdentifier) {
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.all_outputs | SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.all_outputs |
                SigningSerializationFlag.single_input |
                SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.corresponding_output |
                SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.corresponding_output |
                SigningSerializationFlag.single_input |
                SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.no_outputs | SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.no_outputs |
                SigningSerializationFlag.single_input |
                SigningSerializationFlag.fork_id);
        default:
            return undefined;
    }
};
var SignatureIdentifierConstants;
(function (SignatureIdentifierConstants) {
    SignatureIdentifierConstants[SignatureIdentifierConstants["variableIdIndex"] = 0] = "variableIdIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["signingTargetIndex"] = 2] = "signingTargetIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["expectedSegments"] = 3] = "expectedSegments";
})(SignatureIdentifierConstants || (SignatureIdentifierConstants = {}));
export const compilerOperationBCHGenerateSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid signature identifier. Signatures must be of the form: "[variable_id].${name}.[signing_serialization_type]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const algorithm = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingSerializationType = getSigningSerializationType(algorithm);
    if (signingSerializationType === undefined) {
        return `Unknown signing serialization algorithm, "${algorithm}".`;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { operationData } = data;
        if (operationData === undefined) {
            return `Could not construct the signature "${identifier}", signing serialization data was not provided in the compilation data.`;
        }
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const serialization = generateSigningSerializationBCH(sha256, operationData.version, operationData.transactionOutpoints, operationData.transactionSequenceNumbers, operationData.outpointTransactionHash, operationData.outpointIndex, operationData.coveredBytecode, operationData.outputValue, operationData.sequenceNumber, operationData.correspondingOutput, operationData.transactionOutputs, operationData.locktime, signingSerializationType);
        const digest = sha256.hash(sha256.hash(serialization));
        const bitcoinEncodedSignature = Uint8Array.from([
            ...signingAlgorithm(secp256k1)(privateKey, digest),
            ...signingSerializationType
        ]);
        return bitcoinEncodedSignature;
    }
    return `Identifier "${identifier}" refers to a signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
export const compilerOperationBCHGenerateDataSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${name}.[target_script_id]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const scriptId = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingTarget = environment.scripts[scriptId];
    const compiledTarget = resolveScriptIdentifier(scriptId, data, environment);
    if (signingTarget === undefined || compiledTarget === false) {
        return `Data signature tried to sign an unknown target script, "${scriptId}".`;
    }
    if (typeof compiledTarget === 'string') {
        return compiledTarget;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const digest = sha256.hash(compiledTarget.bytecode);
        return signingAlgorithm(secp256k1)(privateKey, digest);
    }
    return `Identifier "${identifier}" refers to a data signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
var SigningSerializationIdentifierConstants;
(function (SigningSerializationIdentifierConstants) {
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["operationIndex"] = 1] = "operationIndex";
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["expectedSegments"] = 2] = "expectedSegments";
})(SigningSerializationIdentifierConstants || (SigningSerializationIdentifierConstants = {}));
// eslint-disable-next-line complexity
export const compilerOperationBCHGenerateSigningSerialization = (identifier, data, environment) => {
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !==
        SigningSerializationIdentifierConstants.expectedSegments) {
        return `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version" or "signing_serialization.all_outputs".`;
    }
    const algorithmOrComponent = identifierSegments[SigningSerializationIdentifierConstants.operationIndex];
    const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
    const { operationData } = data;
    if (operationData === undefined) {
        return `Could not construct the signing serialization "${identifier}", signing serialization data was not provided in the compilation data.`;
    }
    const { sha256 } = environment;
    if (sha256 === undefined) {
        return ScriptGenerationError.missingSha256;
    }
    // eslint-disable-next-line functional/no-conditional-statement
    if (signingSerializationType === undefined) {
        switch (algorithmOrComponent) {
            case 'corresponding_output':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : operationData.correspondingOutput;
            case 'corresponding_output_hash':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : sha256.hash(sha256.hash(operationData.correspondingOutput));
            case 'covered_bytecode_prefix':
                return bigIntToBitcoinVarInt(BigInt(operationData.coveredBytecode.length));
            case 'covered_bytecode':
                return operationData.coveredBytecode;
            case 'locktime':
                return numberToBinUint32LE(operationData.locktime);
            case 'outpoint_index':
                return numberToBinUint32LE(operationData.outpointIndex);
            case 'outpoint_transaction_hash':
                return operationData.outpointTransactionHash;
            case 'output_value':
                return bigIntToBinUint64LE(operationData.outputValue);
            case 'sequence_number':
                return numberToBinUint32LE(operationData.sequenceNumber);
            case 'transaction_outpoints':
                return operationData.transactionOutpoints;
            case 'transaction_outpoints_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutpoints));
            case 'transaction_outputs':
                return operationData.transactionOutputs;
            case 'transaction_outputs_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutputs));
            case 'transaction_sequence_numbers':
                return operationData.transactionSequenceNumbers;
            case 'transaction_sequence_numbers_hash':
                return sha256.hash(sha256.hash(operationData.transactionSequenceNumbers));
            case 'version':
                return numberToBinUint32LE(operationData.version);
            default:
                return `Unknown signing serialization algorithm or component, "${algorithmOrComponent}".`;
        }
    }
    return generateSigningSerializationBCH(sha256, operationData.version, operationData.transactionOutpoints, operationData.transactionSequenceNumbers, operationData.outpointTransactionHash, operationData.outpointIndex, operationData.coveredBytecode, operationData.outputValue, operationData.sequenceNumber, operationData.correspondingOutput, operationData.transactionOutputs, operationData.locktime, signingSerializationType);
};
/* eslint-disable camelcase */
export const getCompilerOperationsBCH = () => ({
    Key: {
        data_signature: compilerOperationBCHGenerateDataSignature('data_signature', secp256k1 => secp256k1.signMessageHashDER),
        // eslint-disable-next-line complexity
        public_key: (identifier, data, environment) => {
            const { keys } = data;
            const { publicKeys, privateKeys } = keys;
            const [variableId] = identifier.split('.');
            if (publicKeys !== undefined &&
                publicKeys[variableId] !== undefined) {
                return publicKeys[variableId];
            }
            if (privateKeys !== undefined &&
                privateKeys[variableId] !== undefined) {
                const { secp256k1 } = environment;
                return secp256k1 === undefined
                    ? ScriptGenerationError.missingSecp256k1
                    : secp256k1.derivePublicKeyCompressed(privateKeys[variableId]);
            }
            return `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`;
        },
        schnorr_data_signature: compilerOperationBCHGenerateDataSignature('schnorr_data_signature', secp256k1 => secp256k1.signMessageHashSchnorr),
        schnorr_signature: compilerOperationBCHGenerateSignature('schnorr_signature', secp256k1 => secp256k1.signMessageHashSchnorr),
        signature: compilerOperationBCHGenerateSignature('signature', secp256k1 => secp256k1.signMessageHashDER)
    },
    SigningSerialization: {
        corresponding_output: compilerOperationBCHGenerateSigningSerialization,
        corresponding_output_hash: compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode: compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode_prefix: compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs: compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs_single_input: compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output: compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output_single_input: compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs: compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs_single_input: compilerOperationBCHGenerateSigningSerialization,
        locktime: compilerOperationBCHGenerateSigningSerialization,
        outpoint_index: compilerOperationBCHGenerateSigningSerialization,
        outpoint_transaction_hash: compilerOperationBCHGenerateSigningSerialization,
        output_value: compilerOperationBCHGenerateSigningSerialization,
        sequence_number: compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints: compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints_hash: compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs: compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs_hash: compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers: compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers_hash: compilerOperationBCHGenerateSigningSerialization,
        version: compilerOperationBCHGenerateSigningSerialization
    }
});
/**
 * TODO: describe
 * @param compilationEnvironment the environment from which to create the compiler
 */
export const createCompiler = (compilationEnvironment) => ({
    debug: (script, data) => compileScript(script, data, compilationEnvironment),
    generate: (script, data) => {
        const result = compileScript(script, data, compilationEnvironment);
        return result.success
            ? { bytecode: result.bytecode, success: true }
            : { errorType: result.errorType, errors: result.errors, success: false };
    }
});
export const createStateCompilerBCH = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
instructions) => createAuthenticationProgramStateCommon(instructions, [], createAuthenticationProgramExternalStateCommonEmpty());
/**
 * TODO: describe
 *
 * @param overrides a compilation environment from which properties will be used
 * to override properties of the default BCH environment
 */
export const createCompilerBCH = async (overrides) => {
    const [sha256, secp256k1, vm] = await Promise.all([
        instantiateSha256(),
        instantiateSecp256k1(),
        instantiateVirtualMachineBCH(instructionSetBCHCurrentStrict)
    ]);
    return createCompiler({
        ...{
            createState: createStateCompilerBCH,
            opcodes: generateBytecodeMap(OpcodesBCH),
            operations: getCompilerOperationsBCH(),
            secp256k1,
            sha256,
            vm
        },
        ...overrides
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvdGVtcGxhdGVzL2xhbmd1YWdlL2NvbXBpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsaUJBQWlCLEVBRWxCLE1BQU0sd0JBQXdCLENBQUM7QUFDaEMsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixxQkFBcUIsRUFDckIsbUJBQW1CLEVBQ3BCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUNMLCtCQUErQixFQUMvQix3QkFBd0IsRUFDekIsTUFBTSxxREFBcUQsQ0FBQztBQUM3RCxPQUFPLEVBRUwsbURBQW1ELEVBQ25ELHNDQUFzQyxFQUN0QyxtQkFBbUIsRUFDbkIsNEJBQTRCLEVBQzVCLDhCQUE4QixFQUM5QixVQUFVLEVBQ1gsTUFBTSx5Q0FBeUMsQ0FBQztBQUlqRCxPQUFPLEVBQXVDLGFBQWEsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUMvRSxPQUFPLEVBR0wsdUJBQXVCLEVBQ3hCLE1BQU0sV0FBVyxDQUFDO0FBdUJuQiw4QkFBOEI7QUFDOUIsTUFBTSxDQUFOLElBQVksdUNBeUJYO0FBekJELFdBQVksdUNBQXVDO0lBQ2pEOztPQUVHO0lBQ0gsc0VBQTJCLENBQUE7SUFDM0I7O09BRUc7SUFDSCxnR0FBcUQsQ0FBQTtJQUNyRDs7T0FFRztJQUNILHdGQUE2QyxDQUFBO0lBQzdDOztPQUVHO0lBQ0gsa0hBQXVFLENBQUE7SUFDdkU7O09BRUc7SUFDSCxvRUFBeUIsQ0FBQTtJQUN6Qjs7T0FFRztJQUNILDhGQUFtRCxDQUFBO0FBQ3JELENBQUMsRUF6QlcsdUNBQXVDLEtBQXZDLHVDQUF1QyxRQXlCbEQ7QUFxQ0QsSUFBSyxxQkFJSjtBQUpELFdBQUsscUJBQXFCO0lBQ3hCLHlGQUFnRSxDQUFBO0lBQ2hFLGtHQUF5RSxDQUFBO0lBQ3pFLHdHQUErRSxDQUFBO0FB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