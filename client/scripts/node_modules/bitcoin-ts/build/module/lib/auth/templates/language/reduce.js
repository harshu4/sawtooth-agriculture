import { flattenBinArray } from '../../../utils/utils';
import { OpcodesCommon } from '../../instruction-sets/common/opcodes';
import { encodeDataPush } from '../../instruction-sets/instruction-sets';
import { authenticationInstructionsAreNotMalformed, disassembleBytecode, parseBytecode } from '../../instruction-sets/instruction-sets-utils';
const pluckStartPosition = (range) => ({
    startColumn: range.startColumn,
    startLineNumber: range.startLineNumber
});
const pluckEndPosition = (range) => ({
    endColumn: range.endColumn,
    endLineNumber: range.endLineNumber
});
const mergeRanges = (ranges) => {
    const unsortedMerged = ranges.reduce(
    // eslint-disable-next-line complexity
    (merged, range) => ({
        ...(range.startLineNumber < merged.startLineNumber
            ? pluckStartPosition(range)
            : range.startLineNumber === merged.startLineNumber &&
                range.startColumn < merged.startColumn
                ? pluckStartPosition(range)
                : pluckStartPosition(merged)),
        ...(range.endLineNumber > merged.endLineNumber
            ? pluckEndPosition(range)
            : range.endLineNumber === merged.endLineNumber &&
                range.endColumn > merged.endColumn
                ? pluckEndPosition(range)
                : pluckEndPosition(merged))
    }), ranges[0]);
    return {
        ...pluckStartPosition(unsortedMerged),
        ...pluckEndPosition(unsortedMerged)
    };
};
const emptyReductionTraceNode = (range) => ({
    bytecode: Uint8Array.of(),
    range
});
/**
 * Aggregate instructions to build groups of non-malformed instructions.
 *
 * --- TODO: delete old stuff below? â€“â€“-
 *
 * So users can write constructions like `OP_PUSHBYTES_2 0x0102` which will
 * evaluate successfully, but instructions which must read over a new-line to
 * make sense (e.g. `OP_PUSHBYTES_2\n0x0102`) should error. This allows for a
 * nice omniscient-debugging experience.
 *
 * **This makes new lines important in evaluations.** However, things
 * can only "break" when new lines are inserted, not when they are removed (e.g.
 * if a script is "minified" to a single line for deployment.)
 *
 * **Implementation note**
 * This method aggregates arrays of instructions by line... a little like
 * Automatic Semicolon Insertion in ECMAScript. ðŸ‘€ In fact, that's a good
 * sign that we're missing a useful language construct here. Maybe instead
 * of this algorithm, we need a new type of wrapper in the language to indicate
 * that bytecode segments are intended to go together.
 *
 * Interestingly, we already use "Containers" in both pushes and evaluations, so
 * this might be quite easy. E.g. wrapping with `()` or `{}`. However, we also
 * want disassembled instructions to be valid input in BTL, so some form of this
 * line-based logic will still be required unless we also change script
 * disassembly form. E.g. instead of `OP_PUSHBYTES_2 0x0102`, something like
 * `(OP_PUSHBYTES_2 0x0102)` or `<0x0102>`. This is something to consider in
 * future versions.
 */
// eslint-disable-next-line complexity
const aggregatedParseReductionTraceNodes = (nodes) => {
    const aggregations = [];
    // eslint-disable-next-line functional/no-let
    let ip = 0;
    // eslint-disable-next-line functional/no-let, init-declarations
    let incomplete;
    // eslint-disable-next-line functional/no-loop-statement
    for (const node of nodes) {
        const bytecode = incomplete === undefined
            ? node.bytecode
            : flattenBinArray([incomplete.bytecode, node.bytecode]);
        const range = incomplete === undefined
            ? node.range
            : mergeRanges([incomplete.range, node.range]);
        // eslint-disable-next-line functional/no-expression-statement
        incomplete = undefined;
        const parsed = parseBytecode(bytecode);
        // eslint-disable-next-line functional/no-conditional-statement
        if (parsed.length === 0) {
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            aggregations.push({
                instructions: [],
                lastIp: ip,
                range
            });
            // eslint-disable-next-line functional/no-conditional-statement
        }
        else if (authenticationInstructionsAreNotMalformed(parsed)) {
            // eslint-disable-next-line functional/no-expression-statement
            ip += parsed.length;
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            aggregations.push({
                instructions: parsed,
                lastIp: ip,
                range
            });
            // eslint-disable-next-line functional/no-conditional-statement
        }
        else {
            // eslint-disable-next-line functional/no-expression-statement
            incomplete = { bytecode, range };
        }
    }
    return {
        aggregations,
        success: true,
        ...(incomplete === undefined
            ? undefined
            : {
                remainingBytecode: incomplete.bytecode,
                remainingRange: incomplete.range,
                success: false
            })
    };
};
/**
 * Evaluate an array of `InstructionAggregation`s with the provided
 * `AuthenticationVirtualMachine`, matching the results back to their source
 * ranges.
 */
export const evaluateInstructionAggregations = (aggregations, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, getState) => {
    const nonEmptyAggregations = aggregations.filter(aggregation => aggregation.instructions.length > 0);
    const evaluationPlan = nonEmptyAggregations.reduce((plan, aggregation) => {
        const instructions = [...plan.instructions, ...aggregation.instructions];
        return {
            breakpoints: [
                ...plan.breakpoints,
                { ip: aggregation.lastIp, range: aggregation.range }
            ],
            instructions
        };
    }, { breakpoints: [], instructions: [] });
    const trace = vm.stateDebug(getState(evaluationPlan.instructions));
    const samples = evaluationPlan.breakpoints.map(breakpoint => ({
        range: breakpoint.range,
        state: trace[breakpoint.ip - 1]
    }));
    const firstInvalidSample = samples.findIndex(sample => sample.state === undefined);
    const errorSample = samples[firstInvalidSample - 1] ??
        samples[firstInvalidSample];
    return errorSample === undefined
        ? {
            samples: samples,
            success: true
        }
        : {
            errors: [
                {
                    error: errorSample.state === undefined
                        ? `Failed to reduce evaluation: vm.debug produced no valid program states.`
                        : `Failed to reduce evaluation: ${errorSample.state.error ??
                            'unknown error'}`,
                    range: errorSample.range
                }
            ],
            samples,
            success: false
        };
};
/**
 * Incrementally evaluate an array of `ScriptReductionTraceNode`s, returning a
 * trace of the evaluation and the resulting top stack item (`evaluationResult`)
 * if successful.
 *
 * @param nodes an array of reduced nodes
 * @param vm the `AuthenticationVirtualMachine` to use in the evaluation
 * @param getState a method which should generate a new ProgramState given an
 * array of `instructions`
 */
// eslint-disable-next-line complexity
export const sampledEvaluateReductionTraceNodes = (nodes, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, getState) => {
    const parsed = aggregatedParseReductionTraceNodes(nodes);
    const evaluated = evaluateInstructionAggregations(parsed.aggregations, vm, getState);
    if (parsed.success && evaluated.success) {
        const samples = evaluated.samples.length > 0
            ? evaluated.samples
            : [{ range: parsed.aggregations[0].range, state: getState([]) }];
        const lastSample = samples[samples.length - 1];
        const lastStackItem = lastSample.state.stack[lastSample.state.stack.length - 1];
        const evaluationResult = lastStackItem === undefined ? Uint8Array.of() : lastStackItem.slice();
        return {
            bytecode: evaluationResult,
            samples,
            success: true
        };
    }
    return {
        bytecode: Uint8Array.of(),
        errors: [
            ...(parsed.success
                ? []
                : [
                    {
                        error: `A sample is malformed and cannot be evaluated: ${disassembleBytecode(OpcodesCommon, parsed.remainingBytecode)}`,
                        range: parsed.remainingRange
                    }
                ]),
            ...(evaluated.success ? [] : evaluated.errors)
        ],
        samples: evaluated.samples,
        success: false
    };
};
/**
 * This method will throw an error if provided a `compiledScript` with
 * compilation errors. To check for compilation errors, use `getCompileErrors`.
 * @param compiledScript the `CompiledScript` to reduce
 * @param vm the `AuthenticationVirtualMachine` to use for evaluations
 * @param createState a method which returns the base `ProgramState` used when initializing evaluations
 */
export const reduceScript = (compiledScript, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, createState) => {
    const source = compiledScript.map(segment => {
        switch (segment.type) {
            case 'bytecode':
                return { bytecode: segment.value, range: segment.range };
            case 'push': {
                if (segment.value.length === 0) {
                    return emptyReductionTraceNode(segment.range);
                }
                const push = reduceScript(segment.value, vm, createState);
                const bytecode = encodeDataPush(push.bytecode);
                return {
                    bytecode,
                    ...(push.errors === undefined ? undefined : { errors: push.errors }),
                    range: segment.range,
                    source: [push]
                };
            }
            case 'evaluation': {
                if (segment.value.length === 0) {
                    return emptyReductionTraceNode(segment.range);
                }
                if (typeof vm === 'undefined' || typeof createState === 'undefined') {
                    return {
                        errors: [
                            {
                                error: 'Both a VM and a createState method are required to reduce evaluations.',
                                range: segment.range
                            }
                        ],
                        ...emptyReductionTraceNode(segment.range)
                    };
                }
                const reductionTrace = reduceScript(segment.value, vm, createState);
                const evaluated = sampledEvaluateReductionTraceNodes(reductionTrace.source, vm, createState);
                const errors = [
                    ...(reductionTrace.errors === undefined ? [] : reductionTrace.errors),
                    ...(evaluated.success ? [] : evaluated.errors)
                ];
                return {
                    ...(errors.length > 0
                        ? {
                            errors,
                            ...emptyReductionTraceNode(segment.range)
                        }
                        : {
                            bytecode: evaluated.bytecode,
                            range: segment.range
                        }),
                    samples: evaluated.samples,
                    source: [reductionTrace]
                };
            }
            case 'comment':
                return emptyReductionTraceNode(segment.range);
            case 'error':
                return {
                    errors: [
                        {
                            error: `Tried to reduce a BTL script with resolution errors: ${segment.value}`,
                            range: segment.range
                        }
                    ],
                    ...emptyReductionTraceNode(segment.range)
                };
            default:
                return new Error(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                `"${segment.type}" is not a known segment type.`);
        }
    });
    const reduction = source.reduce((all, segment) => ({
        bytecode: [...all.bytecode, segment.bytecode],
        ranges: [...all.ranges, segment.range],
        ...(all.errors !== undefined || segment.errors !== undefined
            ? {
                errors: [
                    ...(all.errors === undefined ? [] : all.errors),
                    ...(segment.errors === undefined ? [] : segment.errors)
                ]
            }
            : undefined)
    }), { bytecode: [], ranges: [] });
    return {
        ...(reduction.errors === undefined
            ? undefined
            : { errors: reduction.errors }),
        bytecode: flattenBinArray(reduction.bytecode),
        range: mergeRanges(reduction.ranges),
        source
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9hdXRoL3RlbXBsYXRlcy9sYW5ndWFnZS9yZWR1Y2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUN0RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFFekUsT0FBTyxFQUNMLHlDQUF5QyxFQUN6QyxtQkFBbUIsRUFDbkIsYUFBYSxFQUNkLE1BQU0sK0NBQStDLENBQUM7QUFPdkQsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1QyxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVc7SUFDOUIsZUFBZSxFQUFFLEtBQUssQ0FBQyxlQUFlO0NBQ3ZDLENBQUMsQ0FBQztBQUVILE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTO0lBQzFCLGFBQWEsRUFBRSxLQUFLLENBQUMsYUFBYTtDQUNuQyxDQUFDLENBQUM7QUFFSCxNQUFNLFdBQVcsR0FBRyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ3RDLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxNQUFNO0lBQ2xDLHNDQUFzQztJQUN0QyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDbEIsR0FBRyxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDLGVBQWU7WUFDaEQsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQztZQUMzQixDQUFDLENBQUMsS0FBSyxDQUFDLGVBQWUsS0FBSyxNQUFNLENBQUMsZUFBZTtnQkFDaEQsS0FBSyxDQUFDLFdBQVcs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